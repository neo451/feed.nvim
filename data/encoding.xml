<?xml version="1.0" encoding="gb2312"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>云风的 BLOG</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/" />
    <link rel="self" type="application/atom+xml" href="https://blog.codingnow.com/atom.xml" />
   <id>tag:blog.codingnow.com,2024://1</id>
    <updated>2024-10-25T08:00:11Z</updated>
    <subtitle>思绪来得快去得也快，偶尔会在这里停留</subtitle>
    <generator uri="http://www.sixapart.com/movabletype/">Movable Type 3.2b5</generator>
 
<entry>
    <title>一些进展</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/10/card_pool_building.html" />
    <id>tag:blog.codingnow.com,2024://1.1290</id>
    
    <published>2024-10-25T07:57:44Z</published>
    <updated>2024-10-25T08:00:11Z</updated>
    
    <summary>最近去了一趟南宁马山县。攀岩一周，身体很累，心里很舒服。这周除了爬石头，什么都没想，脑子全部放空了。 “一款好游戏，胜过两款伟大游戏”…… 这世上最容易做的就是“多”，如果我们不小心，就可能会把三四款游戏都塞进一个游戏里。有时候，决定什么内容不该加到游戏里，比决定什么内容该加进入更加总要。―― 《席德梅尔的回忆录》 这几天，读了本书《席德梅尔的回忆录》：《文明》是在陪产假中诞生的，它一开始更像是《铁路大亨》的延续，一个全球规模的《模拟城市》，一个实时模拟游戏。它开发了很久都没有找到正确的方向，一度项目被搁置。而重新继续这个项目后，经过了搁置期的思考，才试着将其改为回合制游戏。 席德还有款失败的作品《恐龙游戏》，他从 1991 年开始鼓捣这款游戏的原型，到 2000 年第 6 届 E3 展后彻底放弃。一开始几个版本像是恐龙版文明，核心玩法是基因衍化，但随机基因突变并不好玩；其后简化了复杂的规则，却变得很无聊。“好像不是你在玩计算机，而是计算机在玩你。如果游戏要一下子表达太多东西，那简化游戏设计会有帮助；但如果你在一款回合制游戏上投入了足够多的时间，你就会希望能够控制所有有趣的决策”。 回合制走不通，游戏原型转为了即时制。席德之前就有一款成功的即时制游戏《葛底斯堡战役》。但这个《恐龙争霸》却因为恐龙题材难以嫁接足够多的远程武器以至于无法平衡。 然后，这款恐龙游戏又演化成了口袋妖怪，或是更接近恐龙万智牌。平平无奇的“借鉴”让这款游戏毫无新意。卡牌形式很好玩，但是“这些卡牌的互动方式与《万智牌》太像了。如果你能加入自己的想法，那借鉴一点创意是可以的，但我从来不觉得恐龙游戏有足够多的新元素可自证清白。”席德忍受不了这一点，最终彻底放弃了这个项目。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="读书" />
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>最近去了一趟南宁马山县。攀岩一周，身体很累，心里很舒服。这周除了爬石头，什么都没想，脑子全部放空了。</p>

<blockquote>
  <p>“一款好游戏，胜过两款伟大游戏”…… 这世上最容易做的就是“多”，如果我们不小心，就可能会把三四款游戏都塞进一个游戏里。有时候，决定什么内容不该加到游戏里，比决定什么内容该加进入更加总要。―― 《席德梅尔的回忆录》</p>
</blockquote>

<p>这几天，读了本书《席德梅尔的回忆录》：《文明》是在陪产假中诞生的，它一开始更像是《铁路大亨》的延续，一个全球规模的《模拟城市》，一个实时模拟游戏。它开发了很久都没有找到正确的方向，一度项目被搁置。而重新继续这个项目后，经过了搁置期的思考，才试着将其改为回合制游戏。</p>

<p>席德还有款失败的作品《恐龙游戏》，他从 1991 年开始鼓捣这款游戏的原型，到 2000 年第 6 届 E3 展后彻底放弃。一开始几个版本像是恐龙版文明，核心玩法是基因衍化，但随机基因突变并不好玩；其后简化了复杂的规则，却变得很无聊。“好像不是你在玩计算机，而是计算机在玩你。如果游戏要一下子表达太多东西，那简化游戏设计会有帮助；但如果你在一款回合制游戏上投入了足够多的时间，你就会希望能够控制所有有趣的决策”。</p>

<p>回合制走不通，游戏原型转为了即时制。席德之前就有一款成功的即时制游戏《葛底斯堡战役》。但这个《恐龙争霸》却因为恐龙题材难以嫁接足够多的远程武器以至于无法平衡。</p>

<p>然后，这款恐龙游戏又演化成了口袋妖怪，或是更接近恐龙万智牌。平平无奇的“借鉴”让这款游戏毫无新意。卡牌形式很好玩，但是“这些卡牌的互动方式与《万智牌》太像了。如果你能加入自己的想法，那借鉴一点创意是可以的，但我从来不觉得恐龙游戏有足够多的新元素可自证清白。”席德忍受不了这一点，最终彻底放弃了这个项目。</p>
]]>
        <![CDATA[<hr />

<p>当我重新拾起自己项目的思路，我觉得我希望它还是一款以策略（而非成长）为主的游戏。我希望单局游戏时间不长，而玩家会面对多种有意义的选择，没有最优解，而是在风险收益间权衡，为长期做规划，同时应对短期挑战（控制损失在可接受范围内）。游戏会有很多随机元素，随机意味着不确定行，玩家一定程度上是在做风险管理。这让想到《<a href="https://blog.codingnow.com/2015/07/rogues_tale.html">Rogue's Tale</a>》，虽然从 steam 评价上看是毁誉参半，但我非常喜欢它。</p>

<p>如果投骰子产生的随机数难以把握，靠自己构筑卡组，以抽卡形式来控制随机性或许更容易接受一些。我很喜欢桌面游戏《Dominion》，所以第一次看到卡牌构筑形式的《杀戮尖塔》时就立刻爱不释手。我想可以考虑一下这种形式的策略游戏。在 steam 上用关键词搜索时，看见了《<a href="https://store.steampowered.com/app/1844130">星际孤儿</a>》。正好，它也是一款以太空船为主题的生存游戏。玩了一百多个小时后，我觉得非常对我的胃口。它也是一款卡牌构筑游戏。steam 评价不算太好，但我不赞同多数差评的意见：它其实不是一款看脸的游戏，虽然看起来系统会刷出一些难解的事件、商店里买不到需要的牌，但这恰恰是玩家需要做“风险管理”的部分。会玩之后，默认难度其实非常简单。真正的难度是从第四级难度开始，需要精心策划每张出牌。</p>

<p>它绝对不是又一个“杀戮尖塔”，其创新点在于“需要玩家持续规划几个回合出牌次序和组合”。而把规划周期拖长看，随机性的影响是微不足道的。玩家要做的是留足备用方案应对不同的可能，并用各种手段消除随机性增加确定性。同时，某个时候不打某一张牌这个决策的重要性就提升了。这在杀戮尖塔类游戏中是比较少见的。</p>

<p>我很喜欢这个游戏策略性带来的感觉，当然，我也不想换个皮再做一个，更不是再来一个杀戮尖塔。只是想到用卡牌形式来玩游戏比较有趣。</p>

<hr />

<p>初步的想法是设计一些足够简单的卡片，用卡片组合的方式来触发游戏中的行动。把卡片分成几类：房间卡、行动卡、物品卡、船员卡。大致对应地点、行动主体、行动对象和动作。打出一串卡片来完成各种操作。例如，在空房间安装一台机器，需要指定位置的房间卡，安装这个行动，需要的机器卡；而机器则是通过（装有生产机器的）房间卡，操作行动，蓝图和材料卡片可以创造出机器卡放入卡组…… </p>

<p>而系统扮演的是一个不对称规则的对手，由设计者实现设计好一个个情景的卡组，洗乱后以机械规则一次打出。玩家就可以看到系统发出的陨石、磁暴等等危机以卡片形式打出。</p>

<p>在游玩过程中，玩家还是在指挥着船员在太空船上进行建造、科研、制造、休整、战斗这些工作，只不过以打牌的形式表达。因为行动被拆解为简单元素，类似 RTS 那样点选一个单位，选择行动及其目标被拆解为多张卡片；每张卡片只有一些基本元素，但组合能表达的行动会很丰富，这样卡组不用太大，避免了巨量卡片组成的卡组不可控，而抽卡机制又保留了一些随机因素。多张卡片的组合使得玩家需要规则几个回合的操作：保留哪张，丢掉哪些，筹齐想要做的事情。</p>

<p>卡牌形式的一个优势是可以先做一套实体卡来试试玩法。现在有《<a href="https://store.steampowered.com/app/286160/Tabletop_Simulator/">Tabletop Simulator</a> 》这样的神器，根本不需要剪刀和画笔。</p>

<p>btw, 似乎卡牌游戏用不到 3d 场景。接下来我还想找个时间好好为 Ant 实现一套 2D 管线，或者直接从里面抽出需要的代码来，重新做一个简单的 2D 引擎。</p>
]]>
    </content>
</entry>
<entry>
    <title>我对电子游戏的分类</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/10/classification_of_games.html" />
    <id>tag:blog.codingnow.com,2024://1.1289</id>
    
    <published>2024-10-11T06:03:42Z</published>
    <updated>2024-10-11T06:09:15Z</updated>
    
    <summary> “首先，设计师创建了一些游戏机制。然后，他们把这些游戏机制用一些具有代表性的虚构元素包装起来。在游戏过程中，这些机制之间会产生一系列事件。这些事件会触动玩家潜意识中的触发器，从而激发出情感。最后，这些情感交织到一起，变成了一种综合的体验。” ―― Tynan Sylvester 《Designing Games: A Guide to Enginerring Experiences》 我非常认同 Rimworld 作者 Tynan 对电子游戏的定义：游戏是一种制造体验的人工系统。游戏用一种工程手段制造体验，目的是激发人类的情感。在《体验引擎》的书中论述，追踪情感的真正源头非常困难，因为情感的触发由大脑的潜意识处理，自动表达的。即使不知道为什么会产生某种情感，我们的理性还是会想当然的为之安排一个原因。这些想当然的原因往往是错的。这种现象被称为情感错位，因为情感错位的存在，想要了解游戏如何影响我们是十分困难的事情。 我最近把游戏开发工作中的具体实现停了下来。因为我意识到，游戏核心固然是设计一些机制，程序实现可以把这些机制做出来并加以测试，但游戏机制只是手段而不是目的。我对游戏设计的理解还不够，所以还需要继续以设计游戏的角度去挖掘游戏深层次的东西。以游戏爱好者的角度去玩那些好评如潮的游戏体会游戏带来的乐趣是不够的，还需要多玩一些毁誉参半但制作者有自己想法的作品。当然，还需要回避一些仅仅是把已有游戏换一个虚构层做出来的仿冒品。 成为好的 Designer 之前，必须做一个更好的 Gamer 。我相信自己比之前是一个更好游戏玩家。因为相比之前，我可以更快的学习游戏规则，忽略游戏的表象，直接去感知作者想表达的东西。玩一些 steam 上只有几个评价且好评率不高的游戏，即使是半成品，对我来说也不算是太难的事了。具体游戏的评价，我大多直接写在 steam 上，而这里，我想记录一些最近想到的比较形而上的总结。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<blockquote>
  <p>“首先，设计师创建了一些游戏机制。然后，他们把这些游戏机制用一些具有代表性的虚构元素包装起来。在游戏过程中，这些机制之间会产生一系列事件。这些事件会触动玩家潜意识中的触发器，从而激发出情感。最后，这些情感交织到一起，变成了一种综合的体验。” ―― Tynan Sylvester 《Designing Games: A Guide to Enginerring Experiences》</p>
</blockquote>

<p>我非常认同 Rimworld 作者 Tynan 对电子游戏的定义：游戏是一种制造体验的人工系统。游戏用一种工程手段制造体验，目的是激发人类的情感。在《体验引擎》的书中论述，追踪情感的真正源头非常困难，因为情感的触发由大脑的潜意识处理，自动表达的。即使不知道为什么会产生某种情感，我们的理性还是会想当然的为之安排一个原因。这些想当然的原因往往是错的。这种现象被称为情感错位，因为情感错位的存在，想要了解游戏如何影响我们是十分困难的事情。</p>

<p>我最近把游戏开发工作中的具体实现停了下来。因为我意识到，游戏核心固然是设计一些机制，程序实现可以把这些机制做出来并加以测试，但游戏机制只是手段而不是目的。我对游戏设计的理解还不够，所以还需要继续以设计游戏的角度去挖掘游戏深层次的东西。以游戏爱好者的角度去玩那些好评如潮的游戏体会游戏带来的乐趣是不够的，还需要多玩一些毁誉参半但制作者有自己想法的作品。当然，还需要回避一些仅仅是把已有游戏换一个虚构层做出来的仿冒品。</p>

<p>成为好的 Designer 之前，必须做一个更好的 Gamer 。我相信自己比之前是一个更好游戏玩家。因为相比之前，我可以更快的学习游戏规则，忽略游戏的表象，直接去感知作者想表达的东西。玩一些 steam 上只有几个评价且好评率不高的游戏，即使是半成品，对我来说也不算是太难的事了。具体游戏的评价，我大多直接写在 steam 上，而这里，我想记录一些最近想到的比较形而上的总结。</p>
]]>
        <![CDATA[<p>对于非社交属性的单人游戏，我认为有三个设计方向：目标、挑战、沙盒。</p>

<p>第一，设计者设计了一件步骤繁多的事情，让玩家在游戏规则（机制）内，一步一步的完成这件事。玩家在游戏过程中获得的长期体验，很大程度来源于有一个预设的目标，一步步抵达终点。</p>

<p>我过去非常喜爱的 JPRG 类型就是典型。近两年玩的比较多的 Factorio ，尤其是星际探索 Mod 也是如此。完成游戏目标这个过程，虽然主干是设计者设计的，但整个路线则可以让出一些不确定的部分让玩家自己填充。另外，我花的时间很多的（数值成长）放置类游戏更是如此。在游戏过程中，游戏者在意的是我在推进游戏进程，最终有一个完结。往这条路线设计的游戏，通常不具备重玩价值，但可以把单次游戏时间设计的很长。例如异星工厂的星际探索 Mod ，我就玩了 1000 小时以上。虽然像 JRPG 几乎都设计了二周目，甚至多周目玩法，但并非真正的重玩，而是为喜欢这个游戏过程的玩家额外设计的延长线。</p>

<p>在这个思路下，是否有战斗系统，战斗系统偏重策略性还是操作性；是基于故事线的角色扮演，还是上帝视角的基地建设，或是自动化工厂…… 这些不同的游戏机制都是为其（玩家一步步推进游戏进程直到完结）服务的。所以，在游戏机制设计的同时，同时设计好在这个机制下玩什么同等重要。后者就是所谓的关卡设计工作。</p>

<p>我在很多年前制作过一款（网络）卡牌对战游戏。游戏规则几乎照搬的卡片召唤师（CULDCEPT）。一开始的想法是，卡片召唤师是一个非常有趣的卡牌对战游戏，如果我们搬到网络上让玩家有一个平台玩应该是很有趣的。为了方便玩家学习复杂的游戏规则，我们制作了对规则逐步深入的多场和系统对战的教学关。当时让我费解的是，大部分（70%）注册用户在玩完长达几个小时的教学关后就离开了游戏，甚至没有尝试和人对战过一次。如果说游戏不好玩吧，这些玩家大多又没有在教学关之间流失。这些教学关设计得并没有太大挑战，在我看来只是体验流畅，并不生硬的传达了教学任务，但并不好玩。花上几个小时，好不容易学会了一个不算太简单的卡牌游戏规则，为什么不想和人玩上一盘呢？我现在的回答是：这个教学任务本身就是一个目标感很强的游戏，哪怕它不好玩，但完成目标这件事都足以驱使玩家完成它。至于后面的人和人的对战，那是完全不同的另一类游戏体验了。</p>

<p>第二，设计者设计了一套规则，并辅以随机性元素生产关卡，让玩家完成一个个挑战。因为随机性元素的存在，玩家需要根据自己对规则的理解，每次都需要重新判断如何应对。玩家在游戏过程中获得的体验，以学习和能力成长为主。获得信息，有所领悟。应对挑战，由失败而激发斗志。</p>

<p>最近几年流行的 Roguelike 元素游戏都可以归为此类。也包括各种生存类游戏。这类游戏的单局时间不会太长，玩家把单局游戏看成是一次短期的挑战任务，随机性元素或精心设计的关卡让玩家检验自己对游戏机制的理解。如果可以引导玩家进入心流状态，单局时间拉得很长也没关系。例如著名的再来一回合文明系列。</p>

<p>这类游戏通常更注重重玩价值。随机性在这里是一个非常重要的元素。这里的随机性指的是游戏机制中的变量，它其实未必是用随机算法任意组合出的东西。只是表示游戏机制中有许多变量参数可供组合变化，玩家需要充分理解机制，才能应对挑战。所以像 baba is you 这样的 puzzle game ，我也把它归为此类。它的关卡并不是随机产生，都是作者精心设计的。我花大量时间玩这种 puzzle game ，并不是为了通关，而是想尝试不同的挑战。</p>

<p>这种游戏对玩家的终点是彻底理解了游戏机制。但设计者如果长期开发的话，可以通过不断扩展和完善游戏机制让玩家一直保持游戏乐趣。</p>

<p>第三，游戏只是一个沙盒，在一套自洽规则下的模拟。在过去，我无法理解像 Townscape 这样仅仅只是随便搭几个房子的模拟器为啥能被称为游戏，且好评如潮。而像 minecraft 这样火爆全球的游戏，很多玩家仅仅只是在里面搭搭积木。玩家自己随意的规划目标，然后自己完成这些目标。游戏本身仅仅充当了一个沙盒模拟装置。</p>

<p>我对此类游戏提不起太大的兴趣，但似乎又无法将其归于上面两类之中。但想想我在异星工厂中曾花掉几十小时就是为了设计一个全自动生产并方便扩建的工厂，似乎也很符合这类游戏提供给玩家的体验。</p>

<hr />

<p>这三类游戏的设计方向并非互斥。好的游戏往往可以同时提供不同方向上的体验，只是有所偏重。我现在分析游戏设计时，倾向于把它作为最高层次的分类标准，然后再给游戏贴上诸如银河城、平台跳跃、基地建设、自动化、RPG 等等标签。</p>
]]>
    </content>
</entry>
<entry>
    <title>最近玩的几个游戏</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/09/few_games.html" />
    <id>tag:blog.codingnow.com,2024://1.1288</id>
    
    <published>2024-09-23T08:47:19Z</published>
    <updated>2024-09-23T10:18:58Z</updated>
    
    <summary>这个月没有写什么程序。月初停下手头的开发工作，花了一周时间，作为 Indieplay 评委试玩了 200 多个参选游戏中的 100 多个。这个工作暂停之后，我就对前两个月对自己想做的游戏产生了许多疑惑。虽然写了不少代码，但仅限于基础玩法的外在功能：我实现了一整套类似边缘世界和缺氧里的工人系统，让小人可以在场景中活动起来，采集物资，建设建筑。让机器可以通上电运转起来，把原料加工为成品。但这些似乎只是一种模拟过程，而并非游戏。 我感觉自己对游戏到底想展现怎样的游戏体验没有清晰的认识。虽然在这篇采访中 也提到，（缺氧的最初设计是）“希望整个游戏运行在一个开放的（虽然简单的）模拟之上”。但我觉得模拟毕竟不是游戏，难以给玩家提供丰富的游戏体验。或者说，至少对于我这样的玩家，没有清晰的游戏目标和挑战是不行的。而且，实现一个丰富的游戏环境模拟面临的挑战我现在还无法评估，至少在当下，这不是我优先想做的东西。 我给游戏定下的基调是基地建设加生存挑战类型，或许应该有一些资源管理和 Roguelike 元素。工人管理或自动化元素是我比较喜欢的，但玩过几千小时类似游戏后，我感觉这些元素只是给予玩家体验的一种手段，并非目的。单独玩某个特定玩法，或许也能有趣，但体验却会大相径庭。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>这个月没有写什么程序。月初停下手头的开发工作，花了一周时间，作为 Indieplay 评委试玩了 200 多个参选游戏中的 100 多个。这个工作暂停之后，我就对前两个月对自己想做的游戏产生了许多疑惑。虽然写了不少代码，但仅限于基础玩法的外在功能：我实现了一整套类似边缘世界和缺氧里的工人系统，让小人可以在场景中活动起来，采集物资，建设建筑。让机器可以通上电运转起来，把原料加工为成品。但这些似乎只是一种模拟过程，而并非游戏。</p>

<p>我感觉自己对游戏到底想展现怎样的游戏体验没有清晰的认识。虽然<a href="https://www.gameres.com/809832.html">在这篇采访中</a> 也提到，（缺氧的最初设计是）“希望整个游戏运行在一个开放的（虽然简单的）模拟之上”。但我觉得模拟毕竟不是游戏，难以给玩家提供丰富的游戏体验。或者说，至少对于我这样的玩家，没有清晰的游戏目标和挑战是不行的。而且，实现一个丰富的游戏环境模拟面临的挑战我现在还无法评估，至少在当下，这不是我优先想做的东西。</p>

<p>我给游戏定下的基调是基地建设加生存挑战类型，或许应该有一些资源管理和 Roguelike 元素。工人管理或自动化元素是我比较喜欢的，但玩过几千小时类似游戏后，我感觉这些元素只是给予玩家体验的一种手段，并非目的。单独玩某个特定玩法，或许也能有趣，但体验却会大相径庭。</p>
]]>
        <![CDATA[<p>比如，我这个月花了不少时间玩 Shapez 2 。这是一个把自动化做到极限的游戏。玩家不再需要考虑能源、制造成本等问题，也没有敌对势力，只需要专心铺工厂，研究如何把工厂规模扩大并保持生产效率最大化。看起来， Factorio 关掉虫子后，也是在干这个事，但我玩下来体验其实是不同的。如果单纯想玩自动化规划，Shapes 显然更轻松有趣；但从游戏性上来说，我更喜欢 Factorio 一点。</p>

<p>我还玩了几天 The Crust 。这个游戏在我的愿望单里放了很久，一发布就开始玩了。我想这是一个 Factorio 和 Rimworld 的混合体。前半部分有很大的 Factorio 成分，玩到十几小时之后，又掺入了殖民地管理和工人分配的玩法。目前它处于 EA 阶段，感觉很多东西还不太成熟。仅就现在完成部分来说，我不是特别喜欢。它的自动化部分略显粗糙，殖民地管理部分又似乎不太完善。关键是交互体验非常糟糕（需要打磨），科技树的平衡更是一言难尽。而它又不像 Factorio 那样有一个坚实的游戏内核，可以通过 Mod 不断扩展玩法；玩起来的体验更依赖于设计好的场景来推动。</p>

<p>最近另一个让我略微失望的游戏是 Frostpunk 2 。一代是我最喜爱的游戏之一，这次 2 的豪华版可以提前 3 天玩游戏，我迫不及待就下单了。用了一天时间快速通关。玩这个游戏，有很大成分是我最近在思考生存类的基地建设游戏该怎样设计。如果没有一代珠玉在前，这也算是不错了。可惜玩过一，核心体验非常雷同。这是一个标准的由预设关卡驱动的基地建设游戏，无尽模式比较无趣。挑战预设剧本是我获得乐趣的主要来源。失败再挑战的循环，让我在一代中花了几十上百小时。但一旦理解了核心规则，抛开“通过玩家抉择来叙事”这个独特的体验，专心考虑如何提高各种数值，游戏不算太难：和一代一样，只需要快速发展科技，回避那些看起来符合短期利益的选择，不采用激进方案，就能达到最优解。这次的二代场面变得宏大，去掉了一代修房子安排工人的微观管理，让游戏体验变成了类似 Excel 表单中的各种进度条。这让我感觉体验不如一代。</p>

<p>和前面提到的 The Crust 一样，这个游戏也有超出同类游戏平均水平的画面质量。这类游戏拥有的高画质反而让我在玩之前就倒扣了期待分，我的这个直觉几乎每次都是对的。如果游戏画面无法帮助玩家更好的理解游戏内涵，那就毫无意义。比如 Frostpunk 2 ，玩家根本不需要关注里面的建筑细节，那么游戏画面精细的刻画建筑就是在浪费开发成本。玩家更关注每个区域的状态和功能，真不如直接给每个区块标记上颜色就够了。而现在默认的画面，看上去场景就是白茫茫一片，关键建筑，即使按住 Alt 凸显出来，还是没有区分度。甚至于，如果有个文本表单都比现在的华丽画面强（不至于让玩家找不到北）。</p>

<p>我最近几年对 Minimalist 极简游戏特别有好感。没有画面加成，极简风的游戏会把注意力放在游戏设计上。一旦核心玩法出众，就很难被掩盖。极简画风也不容易在游戏过程中分心，画面更注重表达游戏规则，学习成本通常更低。例如，我前几天完了一堆塔防游戏，发现最近的新作中，还是<a href="https://store.steampowered.com/app/2617400/">极简塔防</a> 最为有趣。</p>

<p>最近玩的比较多的另一个有塔防元素的游戏是 <a href="https://store.steampowered.com/app/2821800">Drill Core</a> 。我感觉它受到了 Dome Keeper 的启发，但青出于蓝。目前在 steam 的评价中，有许多负面评价集中在挖掘过程里随机性带来的损失对体验的伤害。但我一口气玩了数十小时候，反而觉得那些是设计好的玩法，是游戏特点之一。例如挖掘过程中遇到的落石、喷火块、烦人的地龙，都可以通过合理的规划而避开。游戏似乎故意设计成无法具体对单个工人下指令，必须通过布置任务和设置优先级的方式这种间接的方式控制工人的行为。在充分了解规则后，这反而是一种挑战。只不过现在这种交互方式过于隐晦，而规则又不明确，导致有时体验比较糟糕。在微观管理为主的游戏中，玩家需要的其实是确定性规则，过于智能的 AI 未必是好事。这点我是在去年设计工厂类游戏中学到的：因为想为手机设计的缘故，局限于手机的不便交互，我们去掉了传送带，而使用更智能的无人机运营物流。智能规则导致了物流中的许多不确定性，反而没有传送带这种确定规则好玩了。</p>

<p>随机性带来的不确定性也未必是坏事。但围绕随机性的游戏体验应该是教会玩家做风险管理。例如我最喜欢的 Roguelike <a href="https://blog.codingnow.com/2015/07/rogues_tale.html">Rogue's Tale</a> 就是这样一个风险管理游戏。我最近还发现了另一个被玩家批评随机性太强的游戏叫做 <a href="https://store.steampowered.com/app/1479340/Derelict_Void/">Derelict_Void</a> 。我还没怎么玩，暂时不予评价。关注它是因为这个游戏似乎包含了我目前想做的游戏的各种元素：太空生存、基地建设、资源管理…… 看起来它受到更早的一个游戏 <a href="https://store.steampowered.com/app/334420/Out_There_Edition/">OutThere</a> 启发：基于非常有限的资源探索宇宙，尽可能的活动下一个目的地。玩家需要非常小心的平衡氧气、水、有机物、燃料的使用，尽量养活合适数量的船员。没有和敌对势力的战斗（像 FTL 那样），但依然有极大的生存压力。</p>
]]>
    </content>
</entry>
<entry>
    <title>Ant 引擎的一些改进计划</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/09/ant_plans.html" />
    <id>tag:blog.codingnow.com,2024://1.1287</id>
    
    <published>2024-09-03T03:21:09Z</published>
    <updated>2024-09-03T03:21:48Z</updated>
    
    <summary>我独自开发游戏已经有三个月了。这三个月里，我是 Ant Engine 唯一活跃用户，这是一个很好的机会来挖掘对于一个独立游戏开发者来说，引擎哪些地方有缺失。现阶段，我还是希望把精力放在游戏开发上多一些，所以引擎方面恰恰够用就好。虽然，完善引擎这件事做起来会更愉快，因为这些工作对于我比较顺畅，容易想清楚，游刃有余；而一个人开发游戏，更多的时候是手跟不上心而产生的烦闷。 我还是想挑战一下自己，把游戏设计好，实现好。引擎方面的事情，把想到的东西先记录一下。或许完成手头的游戏项目，沉淀更多，再回头做引擎，愉悦感更强一些。 首先，可视化编辑器 对我来说不重要。所以暂时就不维护了。我更需要的是一些快速验证眼下游戏设计中想法的功能，这些就在游戏 demo 中顺带实现就好，看起来没必要放在编辑器里。这和现阶段没有美术参与也有关系。因为对我自己做独立游戏来说，我不在乎开发进度，先做美术还是后做美术，区别不是很大。本来我自己就喜欢传统 roguelike ，几个 ascii 字符就能脑补所有的美术表现。我想，游戏原型阶段就不需要美术在编辑器里做创作了，用一些几何体就够用。这也是为什么我在三个月前最先完善的就是 Ant 引擎中预制几何体 这个功能的原因。 我在使用 Ant 引擎的时候，发现因为缺乏具体 API 文档而只能不断的阅读源代码（毕竟有很多模块不是我自己动手写的，无法全部了然于心）。而且并非每个模块的设计都满意，这让我经常有修改引擎的冲动。做了一段时间后，我找到一个方法来解决这个开发问题。我可以额外再做一个精简版的框架，按目前开发游戏的需求，从最基本的功能做起，逐步完善。这样就能隔绝引擎已经做好的部分：好用的模块直接做一些浅封装，有问题的部分可以多花些精力做不侵入（破坏老代码）的改进。 本来根据游戏类型的不同，使用引擎的方式就会有很大差异。我希望可以有不同的这样的框架针对具体类型游戏做二次封装。这样，在二次封装上写游戏的花，后面就可以更放心的裁剪底层实现。我更希望让 ECS 框架还原成更原始的设计：面向数据，避免添加太多的辅助模块。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="Ant Engine" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>我独自开发游戏已经有三个月了。这三个月里，我是 Ant Engine 唯一活跃用户，这是一个很好的机会来挖掘对于一个独立游戏开发者来说，引擎哪些地方有缺失。现阶段，我还是希望把精力放在游戏开发上多一些，所以引擎方面恰恰够用就好。虽然，完善引擎这件事做起来会更愉快，因为这些工作对于我比较顺畅，容易想清楚，游刃有余；而一个人开发游戏，更多的时候是手跟不上心而产生的烦闷。</p>

<p>我还是想挑战一下自己，把游戏设计好，实现好。引擎方面的事情，把想到的东西先记录一下。或许完成手头的游戏项目，沉淀更多，再回头做引擎，愉悦感更强一些。</p>

<p>首先，<a href="https://blog.codingnow.com/2023/12/game_engine_editor.html">可视化编辑器</a> 对我来说不重要。所以暂时就不维护了。我更需要的是一些快速验证眼下游戏设计中想法的功能，这些就在游戏 demo 中顺带实现就好，看起来没必要放在编辑器里。这和现阶段没有美术参与也有关系。因为对我自己做独立游戏来说，我不在乎开发进度，先做美术还是后做美术，区别不是很大。本来我自己就喜欢传统 roguelike ，几个 ascii 字符就能脑补所有的美术表现。我想，游戏原型阶段就不需要美术在编辑器里做创作了，用一些几何体就够用。这也是为什么我在三个月前最先完善的就是 <a href="https://github.com/ejoy/ant/discussions/169">Ant 引擎中预制几何体</a> 这个功能的原因。</p>

<p>我在使用 Ant 引擎的时候，发现因为缺乏具体 API 文档而只能不断的阅读源代码（毕竟有很多模块不是我自己动手写的，无法全部了然于心）。而且并非每个模块的设计都满意，这让我经常有修改引擎的冲动。做了一段时间后，我找到一个方法来解决这个开发问题。我可以<a href="https://github.com/ejoy/ant/discussions/199">额外再做一个精简版的框架</a>，按目前开发游戏的需求，从最基本的功能做起，逐步完善。这样就能隔绝引擎已经做好的部分：好用的模块直接做一些浅封装，有问题的部分可以多花些精力做不侵入（破坏老代码）的改进。</p>

<p>本来根据游戏类型的不同，使用引擎的方式就会有很大差异。我希望可以有不同的这样的框架针对具体类型游戏做二次封装。这样，在二次封装上写游戏的花，后面就可以更放心的裁剪底层实现。我更希望让 ECS 框架还原成更原始的设计：面向数据，避免添加太多的辅助模块。</p>
]]>
        <![CDATA[<p>最近还有许多工作是在 UI 上。我对 RmlUI 的方案还是比较满意的。毕竟类 web 的开发有极大的用户基础，各种边角被人打磨过。不过目前的一些实现细节，尤其是 UI 层和游戏层的消息通讯部分存在设计问题。</p>

<p>现在 UI 层和游戏渲染（以及逻辑）处于两个隔离的 Lua VM 中，跑在不同线程上，依赖消息通讯交换数据。引擎简单的封装了消息通讯过程，提供了 RPC 方法。但从游戏逻辑倒 UI 阻塞 RPC 调用，直接使用的话必定产生死锁。这是因为游戏逻辑通常放在 ECS 的一个 system stage 中执行，而处理 UI 层的 RPC 请求在另一个 stage 。为了回避这个死锁问题，需要小心的利用 ltask 的一些异步功能。我做了一些简单的封装后，情况好了一点。这个封装抽象出一个 model 对象，自动在两个层之间做数据同步（只同步差异部分）。在游戏逻辑这边设置 model 的状态，就可以直接在 UI 上展示出来。这个封装还很粗糙，需要我自己多做一些 UI 模块后再改进。</p>

<p>由此，我猜想 ECS 里面可能还需要提供一个 async 的 stage 可能好点。现在的 stage 里如果调用了 ltask.call ，就完全塞死当前帧了。加一个 async 的 stage ，让这里 yield 出去的流程，在下一帧回来这个stage 继续做。这样也可以取代 instance 创建的 onready callback 。只需要把一些消息处理过程放在 async stage 就可以更自然的写。<a href="https://github.com/ejoy/ant/discussions/146">前几个月就做过一点类似的尝试</a> ，感觉还没想好，暂时不打算把这个特性加到引擎中。</p>

<hr />

<p><a href="https://github.com/ejoy/ant/discussions/139">动画模块</a> 是目前引擎比较欠缺的部分。只是我在做游戏原型时还用不上。如果未来做动作向的游戏，这方面的需求就更大了。这个的开发优先级比较低，等实际用起来再解决。</p>

<p><a href="https://github.com/ejoy/ant/discussions/200">材质系统</a> 看起来更值得改进。尤其是我在开发过程中，遇到一个简单的需求：运行时把一个对象改为半透明渲染，折腾了我好几天。最后我还是采用了去年开发游戏过程中使用的方案，为编辑器做好的预制件数据打上 patch ，为每个预制件预生成一个半透明材质的方式。然后在运行时根据需要，在不透明和半透明预制件中做选择（因为现在引擎不支持运行时给对象赋予完全不同的材质）。</p>

<p>说起这个半透明材质问题，我认为本质上还是性能优化问题导致的。理论上，我们可以让所有的对象都是半透明材质，把透明度调为 1.0 ，它就呈现出不透明的状态。调成 0 就消失了。但是，对于渲染来说，不透明和半透明（以及不显示）性能上有本质差别，这会导致不透明的 3d 物体和半透明 3d 物体底层渲染管线都有极大的差别，远非改个材质参数这么简单。或许在 2D 引擎中，这个差别并不大，但对开发者来说，最好不管是 2D 管线还是 3D 管线，都不必在意实现的困难，用起来设置个参数就可以了。这也是引擎要极力解决的问题。在这个（半透明）问题上，我和引擎开发团队的同学讨论了两个晚上，有了一些新的想法。以后有时间我想重构（并简化）相关底层代码。</p>

<p>目前，我不打算在手机平台上开发游戏。这存粹是个人对游戏体验的喜好：我对在触摸屏手机上玩游戏完全失去了兴趣。那么 Ant Engine 的最大努力：直接在开发机上对手机设备上的游戏损失调试，看起来意义就不大了。未来我想把为了实现这个特性而给引擎带来的复杂度做一些简化。尤其是远程调试、VFS 同步、触摸屏支持等。同时，可以增强许多 PC 开发上的体验：尤其是美术资源自动编译这块。我希望可以尽量减少额外的编译环节，让引擎能直接加载更多的通用格式的文件（图片、模型等）。</p>

<p>尤其是材质编译模块，是目前引擎中最为复杂的模块之一。我认为设计也是有问题的（不应该如此复杂）。这一块在上个月开发团队里做了一个晚上的讨论，改进方向下次专门写一篇 blog 介绍。</p>

<p>另外，还有一个大块的计划是重新用 Vulkan 编写 gfx 层，而不再使用 bgfx 这种跨平台方案。这也是后话了。相较用 Vulkan 实现新的 gfx 层，我更希望有机会好好做一套 2D 管线（以及独立的 2D gfx 层）。毕竟 2D 的 gfx 层要简单的多，可以把重心放在如何提供更好的（独立）游戏开发体验上。</p>

<p>想做的事情太多，一件件来吧。</p>

<p>Just for fun</p>
]]>
    </content>
</entry>
<entry>
    <title>一个简单的 C 模块管理器</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/08/cmod.html" />
    <id>tag:blog.codingnow.com,2024://1.1286</id>
    
    <published>2024-08-24T10:14:21Z</published>
    <updated>2024-08-24T10:23:56Z</updated>
    
    <summary>我在用 C 构建项目，尤其是和 Lua 混合使用时，一直很头疼 C 没有一个统一的模块管理器。Lua 的模块管理虽然简单，但毕竟有且够用。一种方法是把 C 模块封装成一个个 Lua 模块，让 Lua 帮助管理，每个 C 模块是独立的，相互不可见。 但当 C 模块之间发生关系时，就比较麻烦。当然，简单的方法是通过链接器把它们都链接在一起，通过函数名前缀以区分。或是利用操作系统的动态库加载器来管理模块。 最近有了一点有趣的想法，觉得一个最简的模块管理器其实复杂度并不高。花了半天功夫实现了一下，感觉还不错。 https://github.com/cloudwu/cmod/...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="语言与设计" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>我在用 C 构建项目，尤其是和 Lua 混合使用时，一直很头疼 C  没有一个统一的模块管理器。Lua 的模块管理虽然简单，但毕竟有且够用。一种方法是把 C 模块封装成一个个 Lua 模块，让 Lua 帮助管理，每个 C 模块是独立的，相互不可见。</p>

<p>但当 C 模块之间发生关系时，就比较麻烦。当然，简单的方法是通过链接器把它们都链接在一起，通过函数名前缀以区分。或是利用操作系统的动态库加载器来管理模块。</p>

<p>最近有了一点有趣的想法，觉得一个最简的模块管理器其实复杂度并不高。花了半天功夫实现了一下，感觉还不错。</p>

<p><a href="https://github.com/cloudwu/cmod/">https://github.com/cloudwu/cmod/</a></p>
]]>
        <![CDATA[<p>我在设计时，刻意回避了使用 macro 魔法，让它的接口保持原始的 C 风格。而且，实现上也不依赖任何内存分配函数，整个管理器需要的内存是一开始由调用者分配好一大块传入的。</p>

<p>这个管理器只管理函数指针，刻意没有去管理其它状态（比如类似事务、COM 管理的就不只是函数接口，还保留对象实例），但还是为每个管理器实例留有一个 userdata 指针，供使用者扩展。</p>

<hr />

<p>其中的 import 函数，也就是通过字符串查找对应的模块，使用的是简单的 O(n) 遍历所有已注册模块的算法。如果接下来有性能需要的话，我会再加一个 hash 表做一些简单的 cache 。</p>
]]>
    </content>
</entry>
<entry>
    <title>32 位 handle 的一种生成方法</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/08/handle_generation.html" />
    <id>tag:blog.codingnow.com,2024://1.1285</id>
    
    <published>2024-08-18T07:44:13Z</published>
    <updated>2024-08-18T11:45:02Z</updated>
    
    <summary>我倾向于在 C 程序里使用整数 handle ，而不是指针。尤其是需要做弱引用的时候。 我认为，一个好的 handle 生成算法，应该满足： 即使 handle 被销毁了，它这个数字也应该被保留，不应该被新的 handle 复用。posix api 里的文件 id 就不符合这一点。 提供一个 api 可以判断一个 handle 是否有效，其时间复杂度为 O(1) 。 从 handle 对应为对象的内存地址的时间复杂度应该为 O(1) ，不应该比指针有明显的性能问题。虽然 hash 表理论上可以满足 O(1) 的时间复杂度，但在糟糕的场景（hash 碰撞发生时）并不能保证这一点。 构造 handle 时间复杂度也为 O(1) 。 handle...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="算法与数据结构" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>我倾向于在 C 程序里使用整数 handle ，而不是指针。尤其是需要做弱引用的时候。</p>

<p>我认为，一个好的 handle 生成算法，应该满足：</p>

<ol>
<li>即使 handle 被销毁了，它这个数字也应该被保留，不应该被新的 handle 复用。posix api 里的文件 id 就不符合这一点。</li>
<li>提供一个 api 可以判断一个 handle 是否有效，其时间复杂度为 O(1) 。</li>
<li>从 handle 对应为对象的内存地址的时间复杂度应该为 O(1) ，不应该比指针有明显的性能问题。虽然 hash 表理论上可以满足 O(1) 的时间复杂度，但在糟糕的场景（hash 碰撞发生时）并不能保证这一点。</li>
<li>构造 handle 时间复杂度也为 O(1) 。</li>
<li>handle 的数字位宽最好不要超过 32 bit 。</li>
</ol>
]]>
        <![CDATA[<p>如是长期运行的程序，第一和第四个需求不能同时成立。但对于非长期程序，理论上 32bit 的数字应该是够用了。</p>

<p>比较简单的实现方案是用一个自增 id ，然后用一张 hash 表来保存 id 到指针的映射。但 hash 表不是严格的 O(1) 复杂度。在 skynet 中，我使用了一个简单的方法：自增 id 后，如果发现 hash 冲突，就再加一，直到不冲突为止。这个方法不能满足第 4 点需求。</p>

<p>当然，同时满足 5 点需求未必有多大的意义，但我最近想到一个有趣的方案，稍微实现了一下，感觉可以做到。</p>

<p>前提是：为了让 32bit 数字就够用，同时有效的 handle 不能太多（大多数场景是这样的）或是在同时有效的 handle 很多时，不要过于频繁销毁和创建很少的几个 handle 。</p>

<p>我们用一个固定 size 为 2^n 的整数数组来管理所有的 handle 。handle 对 size 取模，就是它在这个数组所在的 slot 。然后，我们只需要维护一个完美 hash 表，所有分配出去有效的 handle 都不在这张 hash 表中发生碰撞。这是可以用 O(1) 时间做到的：方法是，每次回收 handle ，都把该 slot 的高 (32-n) bits 加一，这个新的待分配的 id 绝对不会和已分配过的 id 重复。</p>

<p>和简单的循环自增 id 检查冲突的算法相比较，不仅仅是时间上更稳定。最主要的好处是，这个算法更难耗尽 32bit 的空间（发生回绕）。尤其在有效 handle 数量较多时，一旦发生碰撞，自增 id 的方式一下子就会跳过很多数字，而这些数字中大部分是从来没有使用过，本可以安全的分配出去的。</p>

<p>在 handle 销毁（回收时），同时把 handle 串在该数组里的 free list 即可保证下次 O(1) 时间就能完成新 handle 的分配。</p>

<p>举个例子：</p>

<p>如果我们限制最大有效 handle 数为 4 ，如果把 0 保留为无效 id ，那么分配四次后，handle 分别为 1 2 3 4 。</p>

<p>这时，如果我们把 2 销毁，重新分配的话，新的 handle 是 6 而不是 5 （因为 5 和 1 会发生 hash 碰撞）。这时，再销毁 6 然后分配一个新 handle ，这个新的 handle 会是 6+4 = 10 。</p>

<p>在这个算法中，是不是之后所有新增 handle 都比 10 大呢？并不是。如果销毁 1 ，再分配的话，会得到 5 ，5 比 10 小。</p>

<p>这个算法获得的 handle 的数值并非单调递增的，它比自增方案更节省全部的数字空间。</p>

<hr />

<p>如果这个数组满了怎么办？一般我们不用考虑这种情况，应该一开始规划好上限（例如 posix 的同时打开文件数就有上限）。但若是想解决，也可以倍增 size 。只不过 rehash 的过程比较复杂：不光是要把已有的有效 handle 重新填在新数组中，还需要额外标记那些可能用过的 slots 。</p>

<p>我写了一个简单的实现：<a href="https://gist.github.com/cloudwu/dcbf583f7034ef6c0f8adec3f76860f0">https://gist.github.com/cloudwu/dcbf583f7034ef6c0f8adec3f76860f0</a></p>

<p>借助这个数据结构，我们就可以把同类对象分配在一个大数组中，然后用 handle 索引它们，和指针相比，几乎没有额外的开销。并且有如下好处：</p>

<ol>
<li>可以简单的判断一个 handle 是否有效（指针无法安全的做到这点），容易写出健壮的代码。</li>
<li>方便做持久化。</li>
<li>handle 可以用于 C/S 同步。</li>
</ol>
]]>
    </content>
</entry>
<entry>
    <title>基地建设（工厂）类游戏的玩家体验</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/08/base_building_game.html" />
    <id>tag:blog.codingnow.com,2024://1.1284</id>
    
    <published>2024-08-13T13:14:40Z</published>
    <updated>2024-08-13T13:39:32Z</updated>
    
    <summary>这两天思考了一下，基于工厂生产的基地建设类游戏给玩家提供的核心体验到底是什么？以及，我们去年被取消的游戏到底还差点什么。接下来我要制作的游戏的注重点应该在哪里。 我玩的时间比较长的两个基地建设类游戏：异星工厂和缺氧，它们的玩法其实差异很大，但却给人一些近似的体验。对于这个问题，我想过很多次，得出的结论是，它们的确有一些共通之处： 玩家在玩这两个游戏时的情感体验过程非常类似，大致是这样的：...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>这两天思考了一下，基于工厂生产的基地建设类游戏给玩家提供的核心体验到底是什么？以及，我们去年被取消的游戏到底还差点什么。接下来我要制作的游戏的注重点应该在哪里。</p>

<p>我玩的时间比较长的两个基地建设类游戏：异星工厂和缺氧，它们的玩法其实差异很大，但却给人一些近似的体验。对于这个问题，我想过很多次，得出的结论是，它们的确有一些共通之处：</p>

<p>玩家在玩这两个游戏时的情感体验过程非常类似，大致是这样的：</p>
]]>
        <![CDATA[<ol>
<li><p>玩家开始了解基本规则。对于异星工厂来说，就是采集原料，生产加工，生产科技瓶，推进科研发展；对于缺氧来说，是建造设施用来提供小人的各种生存所需，不要让他们死掉。</p></li>
<li><p>让玩家了解游戏的终极目标。这通常是建设一项宏伟的工程。异星工厂和缺氧的原版目标，不约而同的都选择了制作并发射火箭逃离所在星球。</p></li>
<li><p>玩家根据完结游戏的目标和已经了解的游戏规则，在心里做出通关（或是解决阶段性目标）的计划。</p></li>
<li><p>玩家在实施计划的过程中遇到挫折。这通常是发生了一些未曾预料的意外。这个意外并不是系统额外强加进来的，反而是在已透露给玩家的规则下合理发生的。所以，玩家会觉得是自己对规则理解的不够，而不是来源于设计者的恶意。</p></li>
<li><p>玩家修正自己的计划，重新理解游戏系统。如果挫折时由游戏规则内在随机性带来的（缺氧中略微多见），玩家学会应对这些随机性，随之增强自己对抗游戏的自信；而异星工厂（尤其是关闭战斗后）是一个无危机的游戏。但还是会随着自己管理的工厂规模变大，需要更新物流方案，不然生产效率会逐步降低。</p></li>
<li><p>游戏适时介绍一些新系统。在缺氧中变现为一些未曾预料的挑战（比如温度控制在初期没有表现），同时引入新的应对策略；在异星工厂里表现为新的物流方式（火车、无人机等），可以用来提升效率，但这些对玩家是可选的。</p></li>
<li><p>玩家根据新系统迭代自己的计划。</p></li>
</ol>

<hr />

<p>结论：</p>

<p>这类游戏不能将规则简化到一眼望穿，一定要避免变成一个放置游戏，需要提供足够的细节。这些细节的作用是：虽然核心规则可以让玩家做出计划，预测目标该如何完成，但在微观上很难准确预测，细微的偏差会产生混沌效应。即，小小的行为偏差会引起结果的巨变。</p>

<p>一定要给玩家提供一个 "为了结束游戏” 而建立 "长期计划图景" 的舞台。如果缺少这一点，无论是异星工厂的传送带玩法，缺氧的生存玩法，都不足以吸引玩家长期玩下去。</p>

<p>也就是说，微观玩法是帮助玩家建立核心体验的手段，而玩家的核心体验并不在玩这些玩法的游戏过程，而在做出规划然后实施规划上。</p>
]]>
    </content>
</entry>
<entry>
    <title>gameplay 框架设计总结</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/08/gameplay_framework.html" />
    <id>tag:blog.codingnow.com,2024://1.1283</id>
    
    <published>2024-08-08T05:57:48Z</published>
    <updated>2024-08-08T05:59:42Z</updated>
    
    <summary>游戏行业从业 20 多年，一直在做底层开发，即使是帮助其他团队写上层游戏逻辑，也都是实现某些特定的功能模块。直到最近，我想单独开发游戏，才好好想想架子该怎么搭。 从最初的原始 demo 开始，由于缺乏经验，写着写着经常有失控的感觉。好在一个人做，重构的心理负担不大。想改的时候，停下来花上两三天全部重写也不太所谓。最近总算顺畅了一点，感觉需要整理一下思路，所以写一篇 blog 记录一下。 任何复杂的软件问题，都可以通过拆分为若干子问题减少复杂度。 我认为，游戏的上层逻辑，即 gameplay 部分，主要分为三块：数据模型、外在表现和人机交互。 “数据模型”是 gameplay 的核心部分，即把游戏的画面等外在表现以及图形界面、操作控制（鼠标键盘控制器等）等剥离后的东西。如何判断一个模块是否属于数据模型，是否有不属于它的部分没有拆分出去，最简单的方法是看它是否有直接调用游戏引擎的代码。拆分干净后，这块不应该包含任何与图形、界面、时钟、控制输入有关的接口。除了一些必要的文件 IO 接口（主要是用来读取 gameplay 相关的策划数据，写 log ，做数据持久化等），也不应该涉及任何 OS 的 API 。 这样，我们就可以方便的对它进行整体或局部的测试。必要时还可以更换游戏引擎，甚至从文本 roguelike 换到 3D 表现都不会受影响。 “外在表现”当然是指游戏的画面表现、声音声效等等，通常这由游戏引擎实现，但还会有大量的代码存在于 gameplay 的实现中。这一块代码也会维护大量的状态，但不会涉及数据持久化。简单的判断方法是：如果游戏保存进度时，所有这里的所有状态都可以舍弃，下次读取进度后，这些状态又能被重建，而玩家不会感觉丢失了任何数据。 “人机交互”是游戏软件必要的部分，如果没有“人”的存在，游戏也就没有意义了。这块分为两个部分：图形界面用于展示游戏的数据给人看，同时接收一些来至界面的间接输入；控制器（包括并不限于手柄鼠标键盘触摸屏等）对游戏的直接控制。 对于联网游戏，还应包括第四大块：“网络输入”。这篇 blog 仅讨论非联网游戏。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>游戏行业从业 20 多年，一直在做底层开发，即使是帮助其他团队写上层游戏逻辑，也都是实现某些特定的功能模块。直到最近，我想单独开发游戏，才好好想想架子该怎么搭。</p>

<p>从最初的原始 demo 开始，由于缺乏经验，写着写着经常有失控的感觉。好在一个人做，重构的心理负担不大。想改的时候，停下来花上两三天全部重写也不太所谓。最近总算顺畅了一点，感觉需要整理一下思路，所以写一篇 blog 记录一下。</p>

<p>任何复杂的软件问题，都可以通过拆分为若干子问题减少复杂度。</p>

<p>我认为，游戏的上层逻辑，即 gameplay 部分，主要分为三块：数据模型、外在表现和人机交互。</p>

<p>“数据模型”是 gameplay 的核心部分，即把游戏的画面等外在表现以及图形界面、操作控制（鼠标键盘控制器等）等剥离后的东西。如何判断一个模块是否属于数据模型，是否有不属于它的部分没有拆分出去，最简单的方法是看它是否有直接调用游戏引擎的代码。拆分干净后，这块不应该包含任何与图形、界面、时钟、控制输入有关的接口。除了一些必要的文件 IO 接口（主要是用来读取 gameplay 相关的策划数据，写 log ，做数据持久化等），也不应该涉及任何 OS 的 API 。</p>

<p>这样，我们就可以方便的对它进行整体或局部的测试。必要时还可以更换游戏引擎，甚至从文本 roguelike  换到 3D 表现都不会受影响。</p>

<p>“外在表现”当然是指游戏的画面表现、声音声效等等，通常这由游戏引擎实现，但还会有大量的代码存在于 gameplay 的实现中。这一块代码也会维护大量的状态，但不会涉及数据持久化。简单的判断方法是：如果游戏保存进度时，所有这里的所有状态都可以舍弃，下次读取进度后，这些状态又能被重建，而玩家不会感觉丢失了任何数据。</p>

<p>“人机交互”是游戏软件必要的部分，如果没有“人”的存在，游戏也就没有意义了。这块分为两个部分：图形界面用于展示游戏的数据给人看，同时接收一些来至界面的间接输入；控制器（包括并不限于手柄鼠标键盘触摸屏等）对游戏的直接控制。</p>

<p>对于联网游戏，还应包括第四大块：“网络输入”。这篇 blog 仅讨论非联网游戏。</p>
]]>
        <![CDATA[<hr />

<p>对于“数据模型”这块，我在编码时，把这个起名为 gameplay 。可以进一步的分为两大类：被动对象 Object 和 自治体 Actor 。</p>

<p>Object 我认为应按类别分类，每类对象聚合在一起管理。它们可以是场景上的物件、游戏角色等这种会在表现层上找到对应物的东西，也可以是任务清单这种不在表现层呈现的东西（可能会在界面上呈现）。在实现 Object 时，应该理清它的数据和操作这些数据的方法。</p>

<p>对于数据部分，应该在早期就考虑如何持久化，即游戏的 Load Save 该如何实现：通常就是对每类对象的每个个体单独做持久化。为了实现持久化，每个 Object 都应用 id 管理，id 和 typename 是它们的共有属性。</p>

<p>其它数据应该尽量保持相互独立，避免相互引用。如非必要，不提供额外的数据控制的方法。因为一旦要提供特定的方法操作数据，往往是因为多项数据相互关联，必须用单个方法去控制它们来保持一致性。基于这个原则，Object 不应该提供像 update 这样的方法。所以，Object 是静态数据集合，它是被动的。</p>

<p>那么，游戏是怎么运转起来的呢？我们可以再实现一系列的自治体 Actor 。每个 Actor 对应了游戏世界中的一个实体，它可以关联一个或多个 Object ，通过读写 Object 的数据控制它们。大多数游戏在 gameplay 层面不会遇到太大的性能问题，所以这里不考虑并行处理。虽然 Actor 逻辑上是各自独立的，但串行处理可以避免考虑并发读写 Object 的问题。</p>

<p>Actor 使用消息驱动。不同类的 actor 有不同的 update 函数来处理每个 tick 的行为，可以处理消息。游戏世界接收外界输入只能通过向 actor 发送消息完成。actor 通常实现为一个状态机，这样可以让游戏世界中的虚拟角色在不同状态下有不同的行为。actor 需要维护许多的数据中间状态，同时也要考虑持久化问题，但大部分内部状态不应该持久化。大多数情况下，应保证只持久化状态机当前状态的名字就够了。其余运行时状态应当可以根据它重建。</p>

<p>例如：游戏中一个工人，接收了一个任务订单，需要从 A 处拿取一个货物送到 B 处。</p>

<ul>
<li>订单是一个 Object ，数据内容有起点和终点的位置，货物的总类和数量等信息。</li>
<li>工人是一个 Object ，数据内容有它的当前位置、携带物、订单号等。</li>
<li>有一个 Actor 作为工人的控制器，它用于控制工人的行为，比如申请订单、接收订单、执行订单等。</li>
</ul>

<p>而执行订单的过程，又可以分成若干步骤：</p>

<ol>
<li>确定去 A 点的路径</li>
<li>移动到 A 点</li>
<li>获取物品</li>
<li>确定去 B 点的路径</li>
<li>移动到 B 点</li>
<li>放置物品</li>
</ol>

<p>这些步骤，有些是可以立刻完成的，有些则需要若干 tick 。对于需要很多 tick 才能执行完的过程，必定存在一些中间状态，这些状态不必参与持久化。这些运行时的临时状态应当可以被重建。比如，在“移动”这个步骤，一旦外界环境发生变化（例如场景变化了，路程可能被封堵），actor 收到消息，就会把状态机切换到“寻路”这个步骤，之前“移动”步骤的执行过程所创建的中间状态就不需要了。</p>

<p>设计持久化方案是一个优先级很高的事情。因为在考虑持久化时，就会认真设计数据模型。修改数据模型，如果同时考虑不破坏持久化功能，也会更谨慎一些。</p>

<p>不要简单的将 持久化 等同于把 Object 和 Actor 的运行期内存数据结构简单的序列化。持久化更像是把运行时的对象还原为一系列的构造参数，下次加载时可以通过这些参数重新构造运行时结构；而运行时结构往往会考虑性能因素构造成更复杂的数据结构，数据结构中存在一些复杂的相互引用关系。</p>

<p>例如：订单系统的运行时结构可能是 id 到 订单的映射表，这样方便从订单 id 查询到订单。但在做持久化时，把订单保存在一个顺序列表中更好。</p>

<hr />

<p>如何把数据模型表现出来呢？这要看引擎是用什么模式工作。</p>

<p>一般会有两种模式：立即模式（Immediate Mode）和保留模式（Retained Mode）。引擎也可能根据渲染不同类型的东西混合提供两种模式。</p>

<p>如果是立即模式，那么每帧画面由“表现层”（代码中，命名为 visual ）遍历“数据层”的 Object 取出其状态，提交渲染即可。</p>

<p>如果是保留模式，一般我会在表现层为数据模型里的 Object 建立对应的 visual object 。对应关系可以是 1:1 ，也可以是 1:n 即一个数据 object 对应多个 visual object 。而数据层记录每个 tick 的状态变化，最后用消息队列的方式仅把变化传递到表现层。根据这个状态变化消息，修改 visual object 的状态，同步给引擎渲染。</p>

<p>无论是什么模式，都不会在数据模型中直接调用渲染引擎的 API ，数据模型也不会直接持有 visual object 的引用。</p>

<p>渲染层一般不会直接给数据模型中的 Actor 发送消息，而只会读取（不会改变） Object 的状态数据。但如果表现层有额外的反馈设计，比如有物理系统，让物理系统可以对游戏世界发生反馈，一些属于纯表现的，就在表现层自己消化。另一些会影响数据模型的，就会变成一个消息源，向 Actor 发送消息。可以把它们看成是交互层的一部分。</p>

<hr />

<p>交互层通常分为 HUD 、GUI、Controller 。大部分用户输入来至于 Controller ：手柄、鼠标、键盘等。需要对这些设备的原始输入根据场合做一些转换，避免直接处理诸如鼠标按下、手柄摇杆向左这样的消息，而应该转换为更高阶对 gameplay 有意义的消息：例如变成发起攻击、跳跃，向左行走等。还有一些输入来自于 HUD 或 GUI ，更应当避免在 GUI 的代码中直接访问数据模型，更不要直接控制表现层的 visual object ，而应该先转换成 gameplay 的消息。</p>

<p>例如：“存盘”就应该是一条消息，而不应该是直接的函数调用。保存进度和读取进度在消息处理过程中应该只做一个标记，而在每个 tick 末尾再检查这个标记做对应操作（通常是先 save 再 load ）。这样才能更简单的保证数据一致性。</p>

<p>最终在每个 tick ，这些交互层产生的消息会分发发到数据模型中的 actor 。actor 的 update 驱动了整个 gameplay 的状态变化。</p>
]]>
    </content>
</entry>
<entry>
    <title>工人任务分配系统</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/07/task_system.html" />
    <id>tag:blog.codingnow.com,2024://1.1282</id>
    
    <published>2024-07-25T07:49:47Z</published>
    <updated>2024-07-25T07:50:48Z</updated>
    
    <summary>在矮人要塞 like 的游戏中，都有一套基于工人的任务分发系统。玩家通常不能像 RTS 中那样直接操作工人去工作，而是对要做的事情下达任务，等着工人自主去完成。 由于任务数量通常远多于工人数量，这个任务分发系统中大多配有优先级设置，可以让诸多任务有条不紊的进行。调整优先级变成玩家主动操控的渠道。初玩这类游戏，会有点不习惯：感觉难以在微观层面直接做自己像做的事情。像捡块石头放进指定仓库这件事，无法像玩 RTS 游戏那样，先点选工人，再针对石头发出拾取指令…… 但习惯之后，恐怕又回不去了。比如我在玩 Ratopia 时，就对操控鼠王直接干活烦躁不已。 这类游戏，我玩的时间比较长的有三个，按时长排序为：缺氧 (ONI) 、边缘世界 (Rimworld)、矮人要塞 (DF)。其它如 Songs of Syx 、Prison Architect 等很多也有所涉猎。其实，这些游戏在设计工人任务系统的细节上也有所不同。 以我游戏时长最长的缺氧和边缘世界相比较，同样是提供玩家主动操控的能力：Rimworld 可以给工人的任务队列直接下达指令（这更接近 RTS 的玩法），而 ONI 则是通过给单个任务本身排优先级实现的。ONI 设计了警报级任务，可以越过一切优先级设定，强制立刻完成。虽然 ONI 也保留了指挥单个小人移动到指定位置，但实际游戏中几乎没什么用。 对于拾取物品，Rimworld 可以封禁、解禁单个物品，而 ONI 没有这个设计。ONI 的工人几乎不会主动把地上的东西搬入仓库，除非下达清扫指令。 这些细节的不同，可能来源于作者设计时的思维轨迹，很大程度上也取决于游戏的其他玩法。例如 Rimworld 偏重手控成分很重的战斗，而 ONI...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>在矮人要塞 like 的游戏中，都有一套基于工人的任务分发系统。玩家通常不能像 RTS 中那样直接操作工人去工作，而是对要做的事情下达任务，等着工人自主去完成。</p>

<p>由于任务数量通常远多于工人数量，这个任务分发系统中大多配有优先级设置，可以让诸多任务有条不紊的进行。调整优先级变成玩家主动操控的渠道。初玩这类游戏，会有点不习惯：感觉难以在微观层面直接做自己像做的事情。像捡块石头放进指定仓库这件事，无法像玩 RTS 游戏那样，先点选工人，再针对石头发出拾取指令…… 但习惯之后，恐怕又回不去了。比如我在玩 Ratopia 时，就对操控鼠王直接干活烦躁不已。</p>

<p>这类游戏，我玩的时间比较长的有三个，按时长排序为：缺氧 (ONI) 、边缘世界 (Rimworld)、矮人要塞 (DF)。其它如 Songs of Syx 、Prison Architect 等很多也有所涉猎。其实，这些游戏在设计工人任务系统的细节上也有所不同。</p>

<p>以我游戏时长最长的缺氧和边缘世界相比较，同样是提供玩家主动操控的能力：Rimworld 可以给工人的任务队列直接下达指令（这更接近 RTS 的玩法），而 ONI 则是通过给单个任务本身排优先级实现的。ONI 设计了警报级任务，可以越过一切优先级设定，强制立刻完成。虽然 ONI 也保留了指挥单个小人移动到指定位置，但实际游戏中几乎没什么用。</p>

<p>对于拾取物品，Rimworld 可以封禁、解禁单个物品，而 ONI 没有这个设计。ONI 的工人几乎不会主动把地上的东西搬入仓库，除非下达清扫指令。</p>

<p>这些细节的不同，可能来源于作者设计时的思维轨迹，很大程度上也取决于游戏的其他玩法。例如 Rimworld 偏重手控成分很重的战斗，而 ONI 没有战斗成分。Rimworld 强调人物之间的情感联系，ONI 里的都是工具人。</p>

<p>我比较喜欢 ONI 的系统，打算用这个规则打底设计自己的游戏。下面是设计的草稿：</p>
]]>
        <![CDATA[<ol>
<li><p>游戏场景中代做的事情全部被视为任务，任务需要由工人完成。</p></li>
<li><p>任务构成要素主要由对象和行为构成。对象大多为场景中的建筑，也可以是其它一些活动角色，例如某个工人或敌人。</p></li>
<li><p>行为决定了任务的类型，而每种任务类型有一个预设的“类型权重”；玩家可以对任务所属对象设置一个“对象权重”。</p></li>
<li><p>每个工人有自己的任务队列。工人可以设置对任务类型的“偏好权重”，任务对象在场景中的位置和工人之间的距离决定了任务的“位置权重”。将每个任务的所有权重相乘，得到任务分配给每个工人的最终权重。同一个任务会分别进入每个工人的任务队列中。</p></li>
<li><p>有些任务是分配给特定工人的。例如，工人需要周期进食，氧气不足时会就近补充氧气，等等。也会排入对应的任务队列。</p></li>
<li><p>各个任务队列定期刷新，将归属的任务以权重排序。工人从高到低依次完成任务。因为一个任务可以被分配到多个队列中，所以，可以出现工人当前任务被取消的情况。如果扩展战斗系统，而攻击敌人也属于任务的话，同一个任务也可以被并行执行。</p></li>
</ol>

<p>比较特殊的是搬运任务，它通常是建造任务的一个环节，即给建造任务提供原料。它需要把原料从一个地点搬运到建造蓝图的地方。这种搬运任务有两个地点。但给建造蓝图供料时，原料可以有很多候选。我想到两种实现方法：</p>

<p>第一，当一个建造任务被发布后，所有可用的原料均被发布一个供应的子任务，根据和原料和建造任务的距离，给予不同的权重。这样，工人再根据自身的位置，如果开始就近执行一个搬运任务，就立刻把其它搬运任务取消。第二，不考虑不同原料的位置，只要原料可达，就发布一个供应任务，每个工人在考量建造任务权重时，只考虑自己和建造工地的距离。</p>

<p>看起来，第一个方案看起来会有更聪明的表现。因为会倾向于让离原料近的工人就近拿到原料开始搬运。但从实现上看，第二个方案更简单。因为它没有把搬运任务做特殊处理。只在工人执行任务时，再寻找原料。寻早原料变成执行任务的过程，而不在计算权重和分配任务阶段进行。</p>

<hr />

<h2>关于寻路</h2>

<p>昨天我实现了基本的寻路模块。一开始，我认为需要的基本功能是：标记出场景中从 A 点到 B 点的路径。由于场景是玩家一点点搭建起来，随时变化，所以很难对场景做充分的预处理。这样一个寻路模块的时间及空间复杂度都不会太低，而在游戏中恐怕不会太低频使用它。我实现了两版都不是很满意，所以又回头来回顾需求。</p>

<p>结合任务系统来考虑，我突然发现，其实真正需要的不是找到任务 A B 两点间的通行路径，而是找到从同一个点出发，到场景中很多点的路径。因为，任务本身是有位置属性的，这个位置属性决定了它在每个工人的队列中的不同权重；或者从工人角度看，他同时会面对多个不同位置的任务，需要根据距离远近排序。所以，更合理的基础功能应该是：针对每个工人的当前位置，计算出距离可达区域每个位置的行动路线，这用几行代码就可以生成。同理，如果像找到一个建筑任务的所有原料供应点的远近，也可以使用相同的算法。</p>

<p>工人只在开始准备一个新任务时，才需要做一次计算。而一旦他处在执行一个任务的过程中，就不再需要实时计算距离其它任务地的路径。</p>
]]>
    </content>
</entry>
<entry>
    <title>飞船建设部分的设计草案</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/07/building_system.html" />
    <id>tag:blog.codingnow.com,2024://1.1281</id>
    
    <published>2024-07-16T08:35:58Z</published>
    <updated>2024-07-16T11:18:25Z</updated>
    
    <summary>像异星工厂、缺氧、边缘世界都有大量的 mod 。可以通过大改游戏机制，把本体游戏改造成完全体验不同的游戏。这些好玩的 mod 几乎都是一个人完成的。所以我觉得，固然游戏的外层玩法决定了整体体验，但其实开发的总工作量并不大。而且，一旦玩法不满意，也容易修改。 我的游戏开发计划是先完成一些底层基础系统，再考虑完整游戏的全貌。没有上层玩法支撑，光有底层系统玩起来一定寡淡无味，但我认为它们是设计和开发中最重要的一环。 在进一步实现 demo 之前，我设计了一下飞船的建造系统。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>像异星工厂、缺氧、边缘世界都有大量的 mod 。可以通过大改游戏机制，把本体游戏改造成完全体验不同的游戏。这些好玩的 mod 几乎都是一个人完成的。所以我觉得，固然游戏的外层玩法决定了整体体验，但其实开发的总工作量并不大。而且，一旦玩法不满意，也容易修改。</p>

<p>我的游戏开发计划是先完成一些底层基础系统，再考虑完整游戏的全貌。没有上层玩法支撑，光有底层系统玩起来一定寡淡无味，但我认为它们是设计和开发中最重要的一环。</p>

<p>在进一步实现 demo 之前，我设计了一下飞船的建造系统。</p>
]]>
        <![CDATA[<p>游戏世界中的物质分为三种：建筑，零件，原料。</p>

<p>摆放在场景中（飞船）的是建筑，墙体、门、机器、家具这些属于建筑，一旦修建出来就不可任意移动位置。建筑是由零件构成，拆毁建筑会 100% 返还零件。建筑修建是可逆的。</p>

<p>零件是由原料在机器中合成出来，这部分和异星工厂相同。并不一定存在逆向的合成配方。例如，铁板可以合成铁丝，但铁丝并不一定存在变回铁板的方法。所以和建筑不同，加工零件可能是一个不可逆的过程。</p>

<p>飞船（场景）是由四边形网格构成。每个格子永远只能容纳一种物质，要么是建筑的一部分，要么是一种零件。而原料无法直接存在于场景格中，它们必须存在于容器里。建筑和工人都可以是容器。</p>

<p>工人可以在场景格的过道中移动，工人之间不设阻挡。没有建筑的格天然称为过道，部分建筑会占据场景格，成为障碍物。有些建筑将所占据的部分场景格保留为过道。例如门。</p>

<p>每种零件在同一场景格内有一堆叠上限，超过上限就无法容纳在同一格内。有些建筑拥有容器格，容器格和场景格相同，但不存在于场景中（只附属于建筑或工人）。容器还可以存放原料。</p>

<p>每次建设建筑的时候：</p>

<ol>
<li>把所占场景格清空。</li>
<li>把所需零件堆在所占用的场景格上。</li>
<li>工人在建组所占格的建设邻接位（每个格子有 8 个建设邻接位）工作。</li>
<li>工人必须通过过道接近建筑蓝图，工人在过道中只能以四个邻接向移动。</li>
</ol>

<p>注：由多种零件构成的建筑，所占格的数量必须大于等于零件种类。换句话说，如果一格建筑是 1x1 格大小，它就只可能由一种零件构成。</p>

<p>当拆建筑时，也需要工人站在建筑所占格的建设邻接位工作。建筑拆卸后，完全返还零件，置于所占空地。</p>

<p>有些建筑带有不只一格的容器，例如货架，这类建筑会扩展场景的收纳能力。但，拆卸这种建筑必须先排空容器，才能进入拆卸环节。一旦建筑损坏，容器内的物品就不可取出。</p>

<p>加工机器通常带有几格容器，用于保存原料和产品。</p>

<p>工人可以在场景中移动，工人身上带有一或多个容器格。用于建设建筑和安装配件。配件是一种特殊的建筑，存在于工人行动层之外，例如电线和管道，它们可以和建筑同个场景格，拆卸不会回到场景格内，而是进入工人身上的容器中。</p>

<hr />

<p>游戏的建设部分会类似异星工厂和边缘世界的混合体。和异星工厂不同，建设需要把零件运送到场景格上，并由工人消耗工时修建。一旦修好，不可以在场景上移动位置，但可以无损拆卸。零件加工又比较像异星工厂的加工机制，由合成配方决定了生产过程。但又不允许原料直接放在地板上。</p>

<p>我的设计思路是：游戏里的东西尽量具象化，每个东西就是一个视觉上可见的东西，而不是表单上的一个数字。自动化像矮人要塞或缺氧那样，由工人的工作系统驱动完成。不排除后面加上传送带和自动装卸机，但可能把传送带机制和流体管道合并成同一机制（类似缺氧）。</p>
]]>
    </content>
</entry>
<entry>
    <title>室内空气流动模拟</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/07/air_flow_simulation.html" />
    <id>tag:blog.codingnow.com,2024://1.1280</id>
    
    <published>2024-07-10T02:50:27Z</published>
    <updated>2024-07-10T03:19:03Z</updated>
    
    <summary>在设计飞船建造的游戏时，我想做一个空气流动的模拟系统。这里有一个初步的方案，不知道好不好，先记录一下： 空间是由二维的正方形格子构成的，有些格子如墙体会阻止空气流动。每个格子有温度属性及气体质量的记录。不同气体可以同时存在于同一个内，质量单独记录。温度传导系统另外设计。 每个游戏 tick 对每个格子做一次独立计算，根据温度值给出一个概率，这个概率决定了该格气体向周围扩展的比例。 温度越高，越可能将更大比例的气体平均扩散到最多邻接的 8 格空间。 当格子因为建墙而导致空间变化时，把该格内气体全部扩散到临接格，当极端情况下无法做到时，空气锁定在墙体内，不会消失，等待以后满足条件后再扩散出去。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>在设计飞船建造的游戏时，我想做一个空气流动的模拟系统。这里有一个初步的方案，不知道好不好，先记录一下：</p>

<ol>
<li>空间是由二维的正方形格子构成的，有些格子如墙体会阻止空气流动。每个格子有温度属性及气体质量的记录。不同气体可以同时存在于同一个内，质量单独记录。温度传导系统另外设计。</li>
<li>每个游戏 tick 对每个格子做一次独立计算，根据温度值给出一个概率，这个概率决定了该格气体向周围扩展的比例。</li>
<li>温度越高，越可能将更大比例的气体平均扩散到最多邻接的 8 格空间。</li>
<li>当格子因为建墙而导致空间变化时，把该格内气体全部扩散到临接格，当极端情况下无法做到时，空气锁定在墙体内，不会消失，等待以后满足条件后再扩散出去。</li>
</ol>
]]>
        <![CDATA[<p>为什么要做基于格子而不是基于舱室的空气模拟？例如， FTL 的氧气气压模拟就是基于房间的。</p>

<p>因为，这个模拟需要结合游戏本身其它玩法的需要。预计之后会做气闸舱，真空室等设定。需要有一个更微观的空气流动模拟，简单的给船舱加上气压的数值是不够的。和 FTL 不同，我希望做一个基地建设风格的游戏，舱室的结构是动态的，难以以房间为单位计算。</p>

<p>目前有气体流动模拟的游戏中，最流行是缺氧。为什么不直接使用缺氧的模拟系统?</p>

<p>缺氧的基本规则是：每个格子只能有一种物质，这种物质可能有三态：固态、液态、气态。物质会因为温度发生三态转换。不同形态的物质属于不同的东西，每一格不能混装。特殊情况下，气体会直接消失。气体倾向于从高压格流向临近的低压格，并受重力影响向下运动。</p>

<p>缺氧的流体系统是和其它游戏系统相结合的：动植物需要在不同的气体环境下生长，小人会对环境气体尤其是有毒气体做出反应。这些玩法我应该不会做。尤其是，我的游戏地图是平面的，和缺氧不同，没有上下之分，所以不考虑气体重力分层。</p>

<p>对于缺氧来说，它的核心玩法之一是治理无序的自然空间。在玩家拓展空间时，必须考虑原有空间的环境。配合这个设定，才有衍生玩法。而我暂时不想在我的游戏中设计这些。我需要和气体模拟相配合的玩法主要是，根据环境气压影响人物或动植物的状态。</p>

<p>我希望模拟系统简单、准确、符合直觉。</p>

<p>简单：每个格子可以单独运算，不涉及复杂的公式。</p>

<p>直观：尽可能符合玩家的预期。例如，空气从高温区流向低温区，从高气压处流向低气压处，直到平衡。如果空气中混入一点毒气，也会缓慢的随时间扩展，稀释。</p>

<p>准确：规则上可以保证，不会因为模拟计算的误差而出现气体总量的变换。</p>

<hr />

<p>下面还有一些对玩法的初步想法，尚未推敲细节：</p>

<ol>
<li>飞船内需要部署制氧机。制氧机只能通过管道和其它设备连接，不直接向环境排放气体。</li>
<li>氧气需要通过特定设备输入通风管道，通风管道需要通过排气口向环境排放。</li>
<li>船舱中可部署一些氧气面罩供应点，它们由管道供气。</li>
<li>角色随身携带一格氧气面罩，当环境气压在阈值附近变化时自动戴上或取下。氧气消耗完毕后，会自动寻找临近的面罩更换。</li>
</ol>
]]>
    </content>
</entry>
<entry>
    <title>角色动画系统</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/07/avatar_animation.html" />
    <id>tag:blog.codingnow.com,2024://1.1279</id>
    
    <published>2024-07-02T06:38:37Z</published>
    <updated>2024-07-02T07:55:22Z</updated>
    
    <summary>Ant 引擎的角色动画系统还需要完善。 之前我们用 Ant 引擎开发的游戏以机械装置为主，所以并不需要人型角色动画。对于人物角色动作的动画控制，最好有更多的引擎支持。 通常，角色逻辑上的属性和动画表现存在一个映射关系。一个角色，它逻辑上的基本属性可能只有在空间中的坐标。我们编写代码控制它时，只关心它在哪里。但是，在做画面表现时，则需要根据空间坐标这组简单属性，转换为动画播放：如果角色静止不动，就播放 idle 动画，如果正在运动，就播放 walk 动画。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="Ant Engine" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>Ant 引擎的角色动画系统还需要完善。</p>

<p>之前我们用 Ant 引擎开发的游戏以机械装置为主，所以并不需要人型角色动画。对于人物角色动作的动画控制，最好有更多的引擎支持。</p>

<p>通常，角色逻辑上的属性和动画表现存在一个映射关系。一个角色，它逻辑上的基本属性可能只有在空间中的坐标。我们编写代码控制它时，只关心它在哪里。但是，在做画面表现时，则需要根据空间坐标这组简单属性，转换为动画播放：如果角色静止不动，就播放 idle 动画，如果正在运动，就播放 walk 动画。</p>
]]>
        <![CDATA[<p>在引擎底层，每帧只通过坐标这个属性来计算角色该播放哪个动画以及怎样播放，信息是不够的。通常还需要结合过去时间线上的状态变化来推算出当前状态；或是通过几个独立的逻辑属性的组合，得到动画需要的信息。</p>

<p>例如，可以通过空间坐标的变化过程计算出速度；根据是否处于战斗状态决定是警戒行动还是自由行动……</p>

<p>这种从逻辑属性数据到表现用数据的映射关系，一般使用状态机来实现。<a href="https://docs.unity3d.com/Manual/StateMachineBasics.html">Unity 文档对此有一个很好的描述</a>。通过这个状态机，可以生成动画系统底层每帧需要的数据，而开发者只需要简单修改逻辑上的基本属性即可。</p>

<p>动画系统底层看到的是 Entity 当前状态下用于动画渲染的基础数据：一个动画片段的当前帧，或是几个动画片段的加权混合。而状态机只用运行当前帧的当前状态关联的转换逻辑去加工那些基本属性输入。</p>

<p>因为状态机永远处于单一状态，但对于动画来说，从一种状态到另一种状态通常有一个表现过程，所以，状态机中的状态和表现上的状态是有区别的。Unity 把两者区分开，idle ，walk 这种叫 state ，从 idle 到 walk 的过渡期叫  state transition 。从状态机的实现角度看，其实它们都是状态机的节点 node 。</p>

<p>对于非帧动画来说，处于 state 时，通常只有一个动画片段；在 state transition 阶段，则为它连接的两个 state 的动画片段的混合。state 可以触发特定的行为  behaviour ，开发者可以围绕每个特定的 state 来编写逻辑；而 state transition 通常由几个参数控制，对开发者是透明的。</p>

<p>动画状态机的 transition 和动画表现上的多个动画片段混合，是不同的两个东西。</p>

<p>从走路到跑步的过渡阶段可以直接切换两个做好的动画片段，如果是帧动画，动画片段有若干帧构成，通常几个可以衔接在一起的片段，每个片段的最后一帧可以和第一帧衔接在一起，保证循环播放，不同动画片段的第一帧是相同的，允许片段间切换。那么，状态机的 transition 要做的工作一般是，保持上一个状态的动画片段序列播放到最后一帧，可以顺利切换到下一个状态。</p>

<p>以走路过度到跑步为例，状态机在更新时，如果处于走路状态，一旦发现移动速度超过跑步的阈值，就可以切换到 walk to run 这个 transition ，在这个新的 node 中，状态机会继续保持走路的帧动画片段提供给动画底层，直到一个片段周期结束，然后切换到 run 这个新 state ，新的 state 会使用跑步的动画片段从头播放。</p>

<p>对于骨骼动画，往往不受单一动画片段的限制。它可以将多个动画片段混合在一起。在 transition 中，可以逐帧调整多个动画片段的混合权重。</p>

<p>关于人物运动怎样用多个动画片段混合，<a href="https://runevision.com/tech/locomotion/">这里有一篇论文</a> 做了非常详细的解释。</p>

<p>如果是简单的两组动画混合，例如运动方向不变的走路到跑步的过度，使用一维的混合即可。即逐步降低前一个动画片段的权重，同时增加目标动画的权重。</p>

<p>而如果要考虑人物在移动过程中转向，则需要二维的插值。通常使用 Gradient Band Interpolation 。当需要考虑速度变化时，把插值放在极坐标系下效果更好。虽然这需要 O(n2) 的算法复杂度，但通过一张预运算的表，就可以减少到常数时间。</p>

<p>btw, 即使是在 state 中，也可以用到动画的混合。比如，负伤走路的角色和正常走路的角色表现不一样。负伤走路的动画可以是由负伤动画和行走动画叠加混合而来。</p>
]]>
    </content>
</entry>
<entry>
    <title>一些星舰或太空站建设类游戏</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/06/starship_gamelist.html" />
    <id>tag:blog.codingnow.com,2024://1.1278</id>
    
    <published>2024-06-22T08:39:52Z</published>
    <updated>2024-10-07T01:26:02Z</updated>
    
    <summary>因为玩了一些星舰或太空站建造类的游戏，找找灵感。每个游戏都能给我一些启发，因为玩的都不多，所以就不评价了，只做个列表记录。有些还没有出，先加了个愿望单。 Adaptory Astro Colony Avorion Cosmoteer Deep Space Outpost Facteroids Factorio mod : Space Exploration Factorio mod : Warp Drive Machine Far Sector Final Factory Final Upgrade Generation Nova Generation Ship IXION Ostranauts Oxygen Not Included DLC: Spaced Out Rimworld...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>因为玩了一些星舰或太空站建造类的游戏，找找灵感。每个游戏都能给我一些启发，因为玩的都不多，所以就不评价了，只做个列表记录。有些还没有出，先加了个愿望单。</p>

<ul>
<li><a href="https://store.steampowered.com/app/2201620/Adaptory/">Adaptory</a></li>
<li><a href="https://store.steampowered.com/app/1614550/Astro_Colony/">Astro Colony</a></li>
<li><a href="https://store.steampowered.com/app/445220/Avorion/">Avorion</a></li>
<li><a href="https://store.steampowered.com/app/799600/Cosmoteer/">Cosmoteer</a> </li>
<li><a href="https://store.steampowered.com/app/1712110/Deep_Space_Outpost/">Deep Space Outpost</a></li>
<li><a href="https://store.steampowered.com/app/1626530/Facteroids/">Facteroids</a></li>
<li><a href="https://mods.factorio.com/mod/space-exploration">Factorio mod : Space Exploration</a></li>
<li><a href="https://mods.factorio.com/mod/Warp-Drive-Machine">Factorio mod : Warp Drive Machine</a></li>
<li><a href="https://store.steampowered.com/app/1753660/Far_Sector/">Far Sector</a></li>
<li><a href="https://store.steampowered.com/app/1383150/Final_Factory/">Final Factory</a></li>
<li><a href="https://store.steampowered.com/app/919260/Final_Upgrade/">Final Upgrade</a></li>
<li><a href="https://store.steampowered.com/app/1618390/Generation_Nova/">Generation Nova</a></li>
<li><a href="https://store.steampowered.com/app/1638030/Generation_Ship/">Generation Ship</a></li>
<li><a href="https://store.steampowered.com/app/1113120/IXION/">IXION</a></li>
<li><a href="https://store.steampowered.com/app/1022980/Ostranauts/">Ostranauts</a></li>
<li><a href="https://store.steampowered.com/dlc/457140/">Oxygen Not Included DLC: Spaced Out</a></li>
<li><a href="https://steamcommunity.com/workshop/filedetails/?id=1909914131">Rimworld mod : Save Our Ship 2</a></li>
<li><a href="https://store.steampowered.com/app/2450060/Rionag_Survey_Fleet/">Rionag: Survey Fleet</a></li>
<li><a href="https://store.steampowered.com/app/1403740/Space_Architect/">Space Architect</a></li>
<li><a href="https://store.steampowered.com/app/979110/Space_Haven/">Space Haven</a></li>
<li><a href="https://store.steampowered.com/app/672860/StellarHub/">StellarHub</a></li>
<li><a href="https://store.steampowered.com/app/2133570/SpaceSlog/">Space Slog</a></li>
<li><a href="https://store.steampowered.com/app/1380910/Stardeus/">Stardeus</a></li>
<li><a href="https://store.steampowered.com/app/1946440/Starfall_Protocol/">Starfall Protocol</a></li>
<li><a href="https://store.steampowered.com/app/1062000/Starmancer/">Starmancer</a></li>
<li><a href="https://fractalsoftworks.com/">Starsector</a></li>
<li><a href="https://store.steampowered.com/app/574760/Starship_Theory/">Starship Theory</a></li>
<li><a href="https://store.steampowered.com/app/2338890/Starship_Colony/">Starshop Colony</a></li>
<li><a href="https://store.steampowered.com/app/544550/Stationeers/">Stationeers</a></li>
<li><a href="https://store.steampowered.com/app/1465470/The_Crust/">The Crust</a></li>
<li><a href="https://store.steampowered.com/app/1857080/The_Last_Starship/">The Last Starship</a></li>
</ul>
]]>
        

    </content>
</entry>
<entry>
    <title>监视 Lua 对象的修改</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/06/lua_object_monitor.html" />
    <id>tag:blog.codingnow.com,2024://1.1277</id>
    
    <published>2024-06-11T02:12:07Z</published>
    <updated>2024-06-11T08:44:35Z</updated>
    
    <summary>我正在制作的游戏 demo 中，所有对象逻辑上都存在于二维空间，但在 Ant Engine 中通过 3d 渲染方式绘制出来。 我希望有一组简便的 API 方便我控制这些对象的渲染，只是控制它们的位置以及在 Y 轴上的旋转量。Ant Engine 是用场景组件来控制 entity 渲染时的空间状态，但场景节点使用的是 3d 空间的 SRT 即缩放、旋转、位移。而我只需要控制其中的两个坐标轴上的空间位置以及一个旋转轴上的旋转量，直接修改 SRT 太不方便了。而且，使用引擎时，还需要每帧标记被修改过的场景组件对应的 entity ，这也很麻烦。 在 ECS 结构下，最简单的方式是为这些 entity 创建一个额外的组件，里面有 x y r 三个值。通过一个 system 把它们转换到场景节点在 3d 空间下的 SRT 组件中。但如果每帧都全部转换一次显得多余，毕竟大部分...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="Ant Engine" />
            <category term="ECS" />
            <category term="lua与虚拟机" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>我正在制作的游戏 demo 中，所有对象逻辑上都存在于二维空间，但在 Ant Engine 中通过 3d 渲染方式绘制出来。</p>

<p>我希望有一组简便的 API 方便我控制这些对象的渲染，只是控制它们的位置以及在 Y 轴上的旋转量。Ant Engine 是用场景组件来控制 entity 渲染时的空间状态，但场景节点使用的是 3d 空间的 SRT 即缩放、旋转、位移。而我只需要控制其中的两个坐标轴上的空间位置以及一个旋转轴上的旋转量，直接修改 SRT 太不方便了。而且，使用引擎时，还需要每帧标记被修改过的场景组件对应的 entity ，这也很麻烦。</p>

<p>在 ECS 结构下，最简单的方式是为这些 entity 创建一个额外的组件，里面有 x y r 三个值。通过一个 system 把它们转换到场景节点在 3d 空间下的 SRT 组件中。但如果每帧都全部转换一次显得多余，毕竟大部分 entity 不是每帧都会发生变化的。</p>

<p>我用了一个简单的 Lua 技巧来方便开发，下面便是代码：</p>
]]>
        <![CDATA[<pre>
local monitor = {}

local function new_type()
    local changes = {}
    local function touch(obj, k, v)
        local raw = obj.__raw
        changes[raw] = true
        raw[k] = v
        obj.__newindex = raw
    end
    local function new (obj)
        obj.__index = obj
        obj.__newindex = touch
        changes[obj] = true
        return setmetatable({ __raw = obj }, obj)
    end
    local function next_raw(t, key)
        local nkey, nvalue = next(t, key)
        if nkey then
            nkey.__newindex = touch
            return nkey, nvalue
        end
    end
    local function pairs()
        if next(changes) then
            local t = changes
            changes = {}
            return next_raw, t
        else
            return next, changes
        end
    end
    return { pairs = pairs, new = new }
end

local types = setmetatable ({}, {
    __index = function(self, name)
        local t = new_type()
        self[name] = t
        return t
    end })

function monitor.new(typename)
    return types[typename].new
end

function monitor.pairs(typename)
    return types[typename].pairs()
end

TEST = true

if TEST then
    local a = monitor.new "test" { x = 1, y = 2 }
    local b = monitor.new "test" { x = 10, y = 20 }

    local function flush()
        print "====="
        for obj in monitor.pairs "test" do
            print(obj.x, obj.y)
        end
    end

    a.x = -1
    flush()
    b.y = -20
    flush()
    local c = monitor.new "test" { x = 0, y = 0 }
    flush()
else
    return monitor
end
</pre>

<p>从最后的 test 代码可见：我们可以通过 <code>monitor.new "typename" {}</code>创建一个逻辑上有 x y 坐标的 lua 对象，它并不需要是 ECS 的组件，在和 ecs 结合使用的时候，可以把 eid 也放进对象里（在后面遍历的时候，可以对应到 ecs 中的 entity ）。当我们后续修改这些对象时，会把修改过的对象标记在内部一张表中。</p>

<p>通过 <code>for obj in monitor.pairs "typename"</code> 可以遍历所有最近修改过（及新创建）的对象。</p>
]]>
    </content>
</entry>
<entry>
    <title>一个游戏的点子</title>
    <link rel="alternate" type="text/html" href="https://blog.codingnow.com/2024/06/game_idea.html" />
    <id>tag:blog.codingnow.com,2024://1.1276</id>
    
    <published>2024-06-07T04:53:51Z</published>
    <updated>2024-06-07T05:20:40Z</updated>
    
    <summary>宅在家里一个月了。一直在想，如果不考虑迎合市场，不顾及销量，到底应该做一个怎样的游戏才能让自己在制作过程中得到满足。 过年前曾经参加过一次老同事聚餐。组织者说，这屋子坐的都是做游戏的老人了，程序、策划、美术全齐了，还都是不差钱的主。大家要不要凑个局，想想做个啥游戏出来？接下来是一阵沉默，直到有声音说，“我没什么想法”，饭桌上的人纷纷点头，转移了话题。 前段参加一个独立游戏活动，见了些老朋友。有位同学做游戏很多年了，说起这些年的经历，入行头几年是给老板打工，接下来开了家小公司自己做，没赔钱也没赚钱。但干下来感觉变成了给员工打工。为了可以持续发出工资，每次立项都很匆忙，结果还是在不喜欢的游戏项目上耗掉了太多时间。现在干脆把团队安顿好，一个人出来，好好想想到底要做什么。 可见，想清楚做什么很难。单独一人的状态也很难得，没有太多的外界干扰，不为了做事而做，可以慢慢来。 首先，我想做一款游戏，这毋庸置疑。玩游戏是我这些年最大的爱好。光在 steam 上这些年就花掉了上万小时，switch 上也有几千小时。我能在制作游戏的过程中获得我要的东西。 其次，做一款游戏的目的不是为了收入。我对物质生活要求极低，不需要花钱满足欲望。除非需要雇人一起做游戏，不然制作游戏的开销只是自己家庭的日常开销，而我这些年的积蓄已够过完余生。我喜欢的游戏都不需要太复杂的美术资产，这方面并不需要额外的投入。 另一方面，我也不需要用游戏讨好玩家来获得成就感，不需要用一个产品来证明自己，这些成就感的体验都已有过，不是我想追求的东西。 所以，我所需要的是制作过程带来的持续体验，让自己觉得自己在做一件有意义的事。我所喜欢和擅长的其实是：认清问题，解决它们。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="https://blog.codingnow.com/">
        <![CDATA[<p>宅在家里一个月了。一直在想，如果不考虑迎合市场，不顾及销量，到底应该做一个怎样的游戏才能让自己在制作过程中得到满足。</p>

<p>过年前曾经参加过一次老同事聚餐。组织者说，这屋子坐的都是做游戏的老人了，程序、策划、美术全齐了，还都是不差钱的主。大家要不要凑个局，想想做个啥游戏出来？接下来是一阵沉默，直到有声音说，“我没什么想法”，饭桌上的人纷纷点头，转移了话题。</p>

<p>前段参加一个独立游戏活动，见了些老朋友。有位同学做游戏很多年了，说起这些年的经历，入行头几年是给老板打工，接下来开了家小公司自己做，没赔钱也没赚钱。但干下来感觉变成了给员工打工。为了可以持续发出工资，每次立项都很匆忙，结果还是在不喜欢的游戏项目上耗掉了太多时间。现在干脆把团队安顿好，一个人出来，好好想想到底要做什么。</p>

<p>可见，想清楚做什么很难。单独一人的状态也很难得，没有太多的外界干扰，不为了做事而做，可以慢慢来。</p>

<p>首先，我想做一款游戏，这毋庸置疑。玩游戏是我这些年最大的爱好。光在 steam 上这些年就花掉了上万小时，switch 上也有几千小时。我能在制作游戏的过程中获得我要的东西。</p>

<p>其次，做一款游戏的目的不是为了收入。我对物质生活要求极低，不需要花钱满足欲望。除非需要雇人一起做游戏，不然制作游戏的开销只是自己家庭的日常开销，而我这些年的积蓄已够过完余生。我喜欢的游戏都不需要太复杂的美术资产，这方面并不需要额外的投入。</p>

<p>另一方面，我也不需要用游戏讨好玩家来获得成就感，不需要用一个产品来证明自己，这些成就感的体验都已有过，不是我想追求的东西。</p>

<p>所以，我所需要的是制作过程带来的持续体验，让自己觉得自己在做一件有意义的事。我所喜欢和擅长的其实是：认清问题，解决它们。</p>
]]>
        <![CDATA[<hr />

<p>最近玩了很多游戏。有一直想玩但之前没时间玩的博德之门 3 。也有很多新出的游戏如动物井、太空医院、哈迪斯 2 、Laysara: Summit Kingdom 、Final Facory 、Nexus 5X 、Sixty Four …… 很多很多。还回顾了以前玩过的老游戏。</p>

<p>我认为我应该做自己擅长的游戏类型。挑战新类型未尝不可，但可以慢慢来。把我这些年花时间最多（上千小时）的游戏列出来后，得到了三个选题：</p>

<p>第一、自动化工厂类型的游戏，还可以包括 基地建设 和 生存 这样的元素。</p>

<p>第二、有历史感的大战略游戏。记得 30 年前，我最想做的游戏是三国志。其实现在想起来依旧有趣。光荣的三国志系列固然好，但以现在的眼光来看，那些游戏玩点都太陈旧了。我更喜欢群星、维多利亚、十字军之王这些现代战略游戏。这些游戏都有三国题材的 mod ，都并不成功。真正成功的现代三国战略游戏，在我看来只有半个：全面战争：三国。</p>

<p>第三、传统意义上的 Rogue like 。我在 Rogue's Tale 上花了近千小时。Tome4 , Adom , netheck 也都玩过。我喜欢这些游戏玩法的内核，如果接入一些现代游戏的交互元素或许更好？比如博德之门 3 的玩法内核还是古典的 DnD ，但是交互设计上有了巨大的进步。Diablo 在我看来也是 Rogue Like 的进化，动作元素的加入让这个进化非常成功。</p>

<p>有好几天，我都在几个选题间犹豫，对于进一步的思考停滞不前。直到有天我把太空医院的战役通关，突然有了些新的想法。</p>

<p>其实，拘泥于做什么题目更好是没有意义的。任意一个都会很有趣。而做什么游戏也不必标新立异，比如太空医院，我玩的感受就很舒畅。要说和之前的双点医院到底有什么不同？粗看是差不多的。但当初双点医院刚出来时，因对牛蛙的主题医院的旧感情，我第一时间就买了。但当时玩了几个小时就犯困，而这次太空医院我就一口气玩了 20 多小时。为了防止一时偏见，我又重新安装回双点医院，发现感觉并没有错。引用我在 steam 评测中的一句话：“这么说吧，双点医院是旧时代游戏的高清画面重置版，而这个更有现代游戏的感觉。”</p>

<p>延续已有游戏类型其实并无太大问题，但因怀旧或是流行而复刻却没太大意义。加入现代游戏性元素也没问题，但不应硬去缝合。游戏玩点应该自洽，找到整个游戏每个环节应该有什么。从某个特定的乐趣点出发，在此基础上慢慢实现就好了。我突然有了创作欲。</p>

<hr />

<p>核心乐趣：在不规则的有限空间中拼凑不规则板块。</p>

<p>我觉得这是一个非常打动我的玩点：在太空医院中摆放房间时感受到了这一点。玩异星工厂：太空探索 end game 修飞船时，我也曾反反复复的折腾最终飞船的设计图；warptorio 这个 mod 中也是需要在几个楼层的有限空间塞下整个工厂。</p>

<p>乐高、俄罗斯方块这两个是拥有亿万用户的积木游戏。我觉得拼积木板块可以获得某种原始的快感。对于游戏设计，这是一个很好的起点。然后我随意的完善了整个想法。有点杂乱无章，内容过多，不过无所谓，以后慢慢裁剪就好了。</p>

<p>在银河系中已有无数住人的行星，不同的星际种族。玩家扮演一个独立商贸船的舰长，带领一个船组在银河系中做生意，并探索终极秘密。</p>

<p>在游戏的一开始，玩家拥有一艘很小的飞船，只有寥寥几个舱室，和 2,3 名船组成员。在游戏过程中，每段航程从一个星球到另一个星球。每次抵达新的目的地，就可以做短暂的补给：招募新船员、扩展飞船、修改船上的房间设计。</p>

<p>每个舱室内的机器以半自动化形式工作，船员需要窜梭于狭窄的过道，操纵整个飞船。船的隔间设计，和内部机器的摆放及连接关系决定了船的运作效能。异星工厂和缺氧这些游戏确立了相关玩法是成立的，但这里还需要更多的设计工作。</p>

<p>对于每段航程，将是一个小型挑战，玩家要面对：</p>

<ol>
<li>规划燃料、氧气、食物等消耗。</li>
<li>一路上有随机陨石飞来。可以通过：护盾、无人机等防御抵御。（它可能是一个小型塔防游戏）</li>
<li>有许多随机负面事件，电离风暴，恒星耀斑等等。这会考验船的供能情况，动态修理能力。</li>
<li>还会有海盗等敌人出现：需要使用舰载武器攻击，或跃迁逃逸能力。（这里，还可以考虑登船战斗）</li>
</ol>

<p>这会是一个由随机性驱动的游戏，而不是设计好的若干战役：</p>

<p>船员的获得，初始能力点是随机的。人员的成长会决定：操作机器的熟练度、可以使用的高级机器种类。每段航程面临的挑战有随机性。游戏里的船组成员会永久死亡，游戏会因为全部成员的死亡而失败。游戏不会提供随时 Load/Save 的特性，所以每次启程需要考虑后备方案和额外的资源，避免中途失败。</p>

<p>但在每局游戏中，达成特定目标可以解锁遗产，遗产则能永久保留到未来的游戏中。</p>

<hr />

<p>这个题材可以追溯到 <a href="https://en.wikipedia.org/wiki/Wing_Commander:_Privateer">银河飞将：劫掠者</a> ，后续还有自由枪骑兵和星际公民都有不错的口碑。这类游戏，我甚至玩过一个 rogue like 叫做 <a href="https://www.asciisector.net/">asciisector</a> 。当然它们都不以设计飞船为重点。</p>

<p>在上面这个点子的产生过程中，有很多有趣的（我通关过的）游戏给了我启发。包括并不限于：</p>

<ul>
<li><a href="https://store.steampowered.com/app/212680/FTL_Faster_Than_Light/">FTL</a></li>
<li><a href="https://store.steampowered.com/app/785780/OF_MICE_AND_SAND_REVISED">沙漠老鼠团</a></li>
<li><a href="https://store.steampowered.com/app/494730/Galacticare">太空医院</a></li>
<li><a href="https://mods.factorio.com/mod/space-exploration">异星工厂：太空探索</a></li>
<li><a href="https://mods.factorio.com/mod/Warp-Drive-Machine">异星工厂：跃迁引擎</a></li>
</ul>
]]>
    </content>
</entry>

</feed> 

